
// Задачі
// Ось кілька задач різного рівня складності, які поєднують обидві теми. Спробуйте розв'язати їх самостійно.

// Задача 1: Простий калькулятор (if...else if...else)
// Створіть невеликий скрипт, який:

// Оголошує три змінні: a = 10, b = '5', operator = '+'.
// Перевіряє значення змінної operator за допомогою конструкції if...else if...else.
// Якщо operator дорівнює '+', виводить в консоль суму a та b.
// Якщо operator дорівнює '-', виводить різницю a та b.
// Якщо operator дорівнює '*', виводить добуток a та b.
// В іншому випадку (блок else), виводить повідомлення "Невідомий оператор".
// Важливо: зверніть увагу на те, як JavaScript обробляє операції з рядком '5'. Чи потрібно перетворювати його на число?

// const a = 10,
//       b = '5',
//       operator = '*';

// if (operator === '+') {
//     console.log(+a + +b);   // тут для універсальності перетворюю значення кожної змінної в число за доопмогою унарного оператора +  в кожній гілці перед тим як обчислювати
// } else if (operator === '-') {
//     console.log(+a - +b);   // тут для універсальності перетворюю значення кожної змінної в число за доопмогою унарного оператора +  в кожній гілці перед тим як обчислювати
// } else if (operator === '*') {
//     console.log(+a * +b);   // тут для універсальності перетворюю значення кожної змінної в число за доопмогою унарного оператора +  в кожній гілці перед тим як обчислювати
// } else {
//     console.log('Unknown operator');
// }


// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



// Задача 2: Перевірка оцінки (if...else)
// Створіть скрипт, який:

// Оголошує змінну grade і присвоює їй рядок '75'.
// Використовуючи конструкцію if...else, перевіряє, чи є оцінка (змінна grade) прохідною. Припустимо, що прохідний бал — 60 або більше.
// Якщо умова істинна, виводить в консоль "Прохідний бал.".
// Якщо умова хибна, виводить "Непрохідний бал.".
// Важливо: щоб порівняння спрацювало коректно, вам доведеться явно перетворити рядок grade на число.

// const grade = '75';

// if (Number(grade) >= 60) {    // явне перетворення типу в число для уникнення несподіванок через глобальну функцію Number
//     console.log('Passing grade!');
// } else {
//     console.log('Not a passing grade');
// }

// Причина, чому grade.toNumber() не працює, полягає в тому, що toNumber() не є стандартним методом для примітивного типу даних string (рядків) у JavaScript.
// Коли ви оголошуєте const grade = '75';, grade є просто рядком. Рядкові значення мають багато вбудованих методів (наприклад, length, toUpperCase(), substring() тощо), але вони не мають методу toNumber().


// та ж задача з використанням тернароного оператора мій варіант:
// const resultGrade = Number(grade) >= 60 ? console.log('Passing grade!') : console.log('Not a passing grade');

// та ж задача з використанням тернарного оператора виправлений варіант Gemini (з поясненням):
//зазвичай тернарний оператор використовується для присвоєння значення змінній на основі умови, а не для виконання побічних ефектів (як console.log).
// Наприклад, більш типовим використанням було б:
// const message = Number(grade) >= 60 ? 'Passing grade!' : 'Not a passing grade';
// console.log(message);
//У вашому випадку resultGrade отримає значення, яке повертає console.log() (а це undefined), але сам console.log() все одно виконається. Це не помилка, але це не найпоширеніший спосіб використання тернарного оператора.


// -------------------------------------------------------------------------------------------------------------------------------------------------------

// Задача 3: Вік у рядку (if)
// Створіть скрипт, який:

// Оголошує змінну ageText і присвоює їй значення '25'.
// Використовує умовний оператор if для перевірки, чи є вік, вказаний у змінній ageText, більшим за 18.
// Якщо умова істинна, виводить "Доступ дозволено.".
// Важливо: переконайтеся, що ви явно перетворюєте рядок на число перед порівнянням, щоб уникнути помилок.

// const ageText = '25';

// if (+ageText > 18) {   // явне перетворення в число за допомогою унарного оператора +
//     console.log('Access allowed');
// }


// ---------------------------------------------------------------------------------------------------------------------------------


// Задача 1: Перевірка статусу замовлення
// Напишіть скрипт, який:

// Оголошує змінну orderStatus і присвоює їй рядок 'pending'.
// Оголошує змінну hasShipped і присвоює їй логічне значення false.
// Використовує конструкцію if...else if...else для перевірки статусу:
// Якщо orderStatus дорівнює 'completed', виводить в консоль "Замовлення виконано.".
// Якщо orderStatus дорівнює 'pending' І hasShipped є false, виводить "Замовлення очікує відправки.".
// В іншому випадку виводить "Статус замовлення невідомий або відправлено.".
// Пограйтеся: Спробуйте змінити значення orderStatus на 'completed' або hasShipped на true, щоб побачити, як змінюється вивід.


// const orderStatus = 'pending';
// const hasShipped = false;

// if (orderStatus === 'completed') {
//     console.log('Order completed');
// } else if (orderStatus === 'pending' && hasShipped === false) {
//     console.log('Order is waiting for sending');
// } else {
//     console.log('Unknown or shipped order status');
// }


// -------------------------------------------------------------------------------------------------------------------------------------



// Задача 2: Порівняння чисел з різними типами
// Створіть скрипт, який:

// Оголошує дві змінні: num1 = 100 (число) та num2 = '100' (рядок).
// Використовує умовний оператор if для перевірки, чи num1 дорівнює num2 за допомогою оператора ==. Виведіть відповідне повідомлення.
// Використовує інший умовний оператор if для перевірки, чи num1 суворо дорівнює num2 за допомогою оператора ===. Виведіть відповідне повідомлення.
// Поясніть у коментарях до коду, чому результати цих двох порівнянь відрізняються (або не відрізняються).


// const num1 = 100, 
//       num2 = '100';

// if (num1 == num2) {  // поверне true через неявне приведення типів, де рядок '100' перетворюється на число 100 перед порівнянням.
//     console.log('Не строге порівняння!');
// }

// if (num1 === num2) {  // поверне false, оскільки суворе порівняння перевіряє не тільки значення, але й тип даних, і в цьому випадку number не дорівнює string
//     console.log('Строге порівняння');
// }


// --------------------------------------------------------------------------------------------------------------------------------------------

// Задача 3: Доступ до сайту за віком та дозволом
// Напишіть скрипт, який:

// Оголошує змінну userAge і присвоює їй рядок '17'.
// Оголошує змінну hasPermission і присвоює їй рядок 'true' (саме рядок).
// Використовує умовний оператор if з логічним оператором && (І) для перевірки двох умов:
// userAge має бути більшим або дорівнювати 18.
// hasPermission має бути істинним (тобто, перетвореним на булеве true).
// Якщо обидві умови істинні, виводить "Доступ до сайту дозволено.".
// В іншому випадку (використовуючи else), виводить "Доступ до сайту заборонено.".
// Підказка: Не забудьте про приведення типів для userAge та hasPermission перед їх використанням в умовах.

// const userAge = '21',
//       hasPermission = 'true';

// if (+userAge >= 18 && hasPermission === 'true') {
//     console.log('Access to web-site is allowed');
// } else {
//     console.log('Access to web-site is not allowed');
// }

// console.log(Boolean(hasPermission));


// Пояснення Gemini чому Boolean(hasPermission) та !!hasPermission не працюють 
// оператор !!  та глобальна функція Boolean() перетворює значення на булевий тип, ґрунтуючись на тому, чи є воно "truthy" або "falsy". Будь-який не порожній рядок (включно з 'true', 'false', 'hello') є "truthy". Тому !!'true' завжди повертатиме true, оскільки рядок 'true' сам по собі не є порожнім.
// Однак, коли ви використовуєте Boolean(), ви явно вказуєте JavaScript, що хочете отримати булеве значення. У випадку з рядками, якщо ви хочете перетворити рядок 'true' на булеве true, а рядок 'false' на булеве false, вам потрібно буде зробити це вручну або за допомогою умовної логіки, оскільки Boolean('false') теж поверне true (бо рядок 'false' не порожній і є "truthy").
// Ваша змінна hasPermission має значення 'true' (рядок). Якщо ви хочете, щоб вона стала булевим true саме тому, що її вміст є рядком "true", а не просто тому, що вона не порожня, вам потрібно буде порівняти її вміст
// hasPermission === 'true'


// --------------------------------------------------------------------------------------------------------------------------------

// Задача 1: Загальний доступ
// Створіть скрипт, який:

// Оголошує дві змінні: isLoggedIn = true та hasPermission = false.
// Використовуючи оператор &&, перевіряє, чи є користувач авторизованим і чи має він дозвіл.
// Якщо умова істинна, виводить "Доступ дозволено.".
// В іншому випадку виводить "Доступ заборонено.".
// Пограйтеся: Спробуйте змінити значення змінних, щоб побачити, як це впливає на результат.

// const isLoggedIn = true,
//       hasPermission = false;

// if (isLoggedIn && hasPermission) {  // якщо isLoggedIn true та hasPermission true то доступ дозволено
//     console.log('Доступ дозволено!');
// } else {
//     console.log('Доступ заборонено!');
// }

// -------------------------------------------------------------------------------------------------------------------


// Задача 2: Вільний час
// Напишіть скрипт, який:

// Оголошує дві змінні: isWeekend = true та isHoliday = false.
// Використовуючи оператор ||, перевіряє, чи сьогодні вихідний або святковий день.
// Якщо умова істинна, виводить "Можна відпочивати.".
// В іншому випадку виводить "Час працювати.".

// const isWeekend = true,
//       isHoliday = false;

// if (isWeekend || isHoliday) {  // якщо isWeekend true або isHoliday true (один з них) то Можна відпочивати
//     console.log('Мона відпочивати');
// } else {
//     console.log('Час працювати');
// }


// --------------------------------------------------------------------------------------------------------------------------

// Задача 3: Складний пароль
// Напишіть скрипт, який:

// Оголошує змінну password = 'Pa$$w0rd'.
// Оголошує дві змінні, які будуть перевіряти певні умови: hasUpperCase = false та hasSpecialChar = true.
// Використовує логічний оператор && для перевірки, чи довжина пароля більша за 8 символів і чи містить він великі літери (hasUpperCase) і чи містить він спеціальні символи (hasSpecialChar).
// Якщо всі умови істинні, виводить "Пароль надійний.".
// В іншому випадку виводить "Пароль не надійний.".
// Підказка: Використовуйте вбудовану властивість length для рядків, щоб отримати довжину пароля.

// const password = 'Pa$$w0rd';
// const hasUpperCase = false,
//       hasSpecialChar = true;

// if (password.length > 8 && hasUpperCase && hasSpecialChar) {  // якщо всі(кожна) умови true то пароль надійний
//     console.log('Пароль надійний!');
// } else {
//     console.log('Пароль не надійний!');
// }


// ---------------------------------------------------------------------------------------------------------------------

// Задача 1: Перевірка права на знижку
// Створіть скрипт, який:

// Оголошує змінні: isMember = false, orderTotal = 150 та isFirstTimeCustomer = true.
// Використовуючи комбінацію логічних операторів, перевіряє умову для отримання знижки:
// Знижку отримує клієнт, який є учасником програми (isMember) або сума його замовлення (orderTotal) більша за 100 і він є новим клієнтом (isFirstTimeCustomer).
// Якщо умова істинна, виводить "Клієнт має право на знижку.".
// В іншому випадку виводить "Клієнт не має права на знижку.".
// Підказка: Будьте уважні до порядку виконання операцій. Якщо потрібно, використовуйте круглі дужки.

// const isMember = false;
// const orderTotal = 150;
// const isFirstTimeCostumer = true;

// if (isMember || (orderTotal > 100 && isFirstTimeCostumer)) {  // якщо isMember true або (orderTotal > 100 та isFirstTimeCostumer true) клієнт має знижку
//     console.log('Клієнт має право на знижку.');
// } else {
//     console.log('Клієнт не має права на знижку.');
// }


// Задача 2: Визначення назви користувача (коротке замикання)
// Створіть скрипт, який:

// Оголошує змінні: userLoggedIn = null та defaultUser = 'Гість'.
// Використовує логічний оператор || для присвоєння значення змінній currentUsername.
// Якщо userLoggedIn має значення, currentUsername має отримати це значення.
// Якщо userLoggedIn є "falsy" (наприклад, null), currentUsername має отримати значення defaultUser.
// Виведіть значення currentUsername в консоль.
// Пограйтеся: Спробуйте змінити userLoggedIn на рядок, наприклад 'Іван'. Як це вплине на результат завдяки механізму "короткого замикання"?

// варіант 1 з if...else
// const userLoggedIn = undefined;
// const defaultUser = 'Гість';
// let currentUsername = '';

// if (userLoggedIn) {
//     currentUsername = userLoggedIn;
// } else {
//     currentUsername = defaultUser;
// }
// console.log(currentUsername);

//варіант 2 з логічним оператором ||

// const userLoggedIn = null;
// const defaultUser = 'Гість';
// let currentUsername = userLoggedIn || defaultUser;  // currentUsername буде = ім'я (якщо воно є в userLoggedIn) або Гість (якщо в userLoggedIn нема імені)
// console.log(currentUsername);

// -------------------------------------------------------------------------------------------------------------------------------------------------------------

// Задача 3: Доступ до вмісту
// Напишіть скрипт, який:

// Оголошує змінні: userRole = 'admin', isSubscriptionActive = false та isBetaTester = true.
// Використовує комбінацію && та || для перевірки доступу:
// Доступ дозволено, якщо користувач має роль 'admin' АБО його підписка активна (isSubscriptionActive) І він є бета-тестером (isBetaTester).
// Якщо доступ дозволено, виводить "Доступ до секретного контенту дозволено.".
// В іншому випадку виводить "Доступ заборонено.".
// Підказка: Ретельно продумайте, як згрупувати умови, щоб логіка відповідала завданню.


// const userRole = 'AdmiN';
// const isSubscriptionActive = false;
// const isBetaTester = true;

// if (userRole.toLocaleLowerCase() === 'admin' || (isSubscriptionActive && isBetaTester)) {
//     console.log('Доступ до секретного контенту дозволено.');
// } else {
//     console.log('Доступ заборонено.');
// }

// ----------------------------------------------------------------------------------------------------------------------------


// Задача 1: Вхід у систему
// Створіть скрипт, який перевіряє можливість входу користувача.
// Оголосіть змінні: username = 'user', password = 'password123', isUserActive = true.
// Напишіть умову, яка перевіряє:
// Логін — 'user' І пароль — 'password123' І користувач активний.
// Якщо всі умови істинні, виведіть "Вхід успішний.".
// В іншому випадку виведіть "Помилка входу.".
// Пограйтеся: Спробуйте змінити значення однієї зі змінних, щоб побачити, як це впливає на результат.

// const userName = 'User';
// const password = 'password123';
// const isUserActive = true;

// if (userName.toLowerCase() === 'user' && password === 'password123' && isUserActive) {
//     console.log('Вхід успішний.');
// } else {
//     console.log('Помилка входу.');
// }

// ----------------------------------------------------------------------------------------------------------------------

// Задача 2: Доступ до преміум-контенту
// Напишіть скрипт, який перевіряє доступ до преміум-контенту.
// Оголосіть змінні: isPremium = true, hasCoupon = false, orderPrice = 90.
// Використайте комбінацію логічних операторів для перевірки:
// Користувач має доступ, якщо він є преміум-користувачем АБО він має купон ТА сума його замовлення більша за 100.
// Якщо умова істинна, виведіть "Доступ до преміум-контенту дозволено.".
// В іншому випадку виведіть "Доступ заборонено.".
// Пограйтеся: Спробуйте змінити значення змінних, щоб перевірити різні сценарії.

// const isPremium = true;
// const hasCoupon = false;
// const orderPrice = 90;

// if (isPremium || (hasCoupon && orderPrice > 100)) {
//     console.log('Доступ до преміум-контенту дозволено.');
// } else {
//     console.log('Доступ заборонено.');
// }

// ---------------------------------------------------------------------------------------------------------------


// Задача 3: Перевірка наявності даних
// Напишіть скрипт, який використовує "коротке замикання" для перевірки наявності даних.
// Оголосіть змінні: userName = 'Іван', userEmail = '', userPhone = 0.
// Використайте логічний оператор && для перевірки, чи є всі три змінні truthy.
// Якщо всі три змінні є truthy, виведіть "Всі дані наявні.".
// В іншому випадку, виведіть "Недостатньо даних.".
// Підказка: Не використовуйте явне порівняння === true.

// const userName = 'Іван';
// const userEmail = '';
// const userPhone = 0;

// if (userName && userEmail && userPhone) {
//     console.log('Всі дані наявні.');
// } else {
//     console.log('Недостатньо даних.');
// }


// --------------------------------------------------------------------------------------------------------------------------


/**
 * ЗАВДАННЯ 1: Цикл `for` та оператор `if`
 * Наша попередня розмова була про добуток чисел від -5 до 10.
 * Тут є аналогічне завдання, але з іншим діапазоном.
 * Порахуйте суму всіх цілих чисел у діапазоні від -3 до 7,
 * але пропустіть число 0. Використайте цикл `for` та оператор `if`.
 * Після виконання, виведіть результат у консоль.
 */
// let sum = 0;

// for (let i = -3; i <= 7; i++) {
//   if (i === 0) {
//     continue;
//   }
//   sum += i;
// }

// console.log("Результат завдання 1 (сума): ", sum); // Очікуваний результат: 22


// -------------------------------------------------------

/**
 * ЗАВДАННЯ 2: Цикл `while`
 * Створіть змінну `i` зі значенням 5.
 * Використайте цикл `while`, щоб віднімати 1 від `i` на кожній ітерації.
 * Цикл має виконуватись, поки `i` не стане меншим або дорівнюватиме 0.
 * Всередині циклу виведіть поточне значення `i`.
 */
// let i = 5;

// while(i > 0) {
//     console.log(i);
//     i -= 1;
// }

// console.log("Результат завдання 2: цикл завершено.");


// -------------------------------------------------------

/**
 * ЗАВДАННЯ 3: Цикл `do...while`
 * Цей цикл завжди виконується хоча б один раз.
 * Створіть змінну `x` зі значенням 10.
 * Використайте цикл `do...while` так, щоб він виконав блок коду
 * один раз, навіть якщо умова `x < 5` не виконується з самого початку.
 * У тілі циклу виведіть `x` та потім відніміть від нього 1.
 */
// let x = 10;
// do {
//     console.log(x);
//     x--;
// } while (x < 5)

// console.log("Результат завдання 3: цикл завершено.");


// -------------------------------------------------------

/**
 * ЗАВДАННЯ 4: `break`
 * Використайте цикл `for`, щоб перебирати числа від 1 до 100.
 * Як тільки ви знайдете перше число, яке ділиться на 17 без залишку,
 * виведіть його в консоль і негайно зупиніть цикл за допомогою `break`.
 */
// for (let i = 1; i <= 100; i++) {
//     if (i % 17 === 0) {
//         console.log(i);
//         break;
//     }
// }

// console.log("Результат завдання 4: цикл завершено."); // Очікуваний результат: 17


// -------------------------------------------------------

/**
 * ЗАВДАННЯ 5: `continue`
 * Використайте цикл `for` для виведення чисел від 1 до 20.
 * Але за допомогою оператора `continue` пропустіть всі парні числа
 * (ті, що діляться на 2 без залишку).
 * Тобто, в консолі мають бути лише непарні числа.
 */
// for (let i = 1; i <= 20; i++) {
//     if (i % 2 === 0) {
//         continue;
//     }
//     console.log(i);
// }

// console.log("Результат завдання 5: цикл завершено.");



/**
 * ЗАВДАННЯ 1: Задача "FizzBuzz"
 * Напишіть цикл, який перебирає числа від 1 до 100.
 * Для кожного числа, виконайте наступні умови:
 * 1. Якщо число ділиться на 3 без залишку, виведіть "Fizz".
 * 2. Якщо число ділиться на 5 без залишку, виведіть "Buzz".
 * 3. Якщо число ділиться і на 3, і на 5 без залишку, виведіть "FizzBuzz".
 * 4. В усіх інших випадках просто виведіть саме число.
 *
 * Використайте цикл `for` та умовні оператори `if...else if...else`.
 */
// console.log("--- ЗАВДАННЯ 1: FizzBuzz ---");

// for (let i = 1; i <= 100; i++) {
//     if (i % 3 === 0 && (i % 5 === 0)) {
//         console.log('FizzBuzz');
//     } else if (i % 3 === 0) {
//         console.log('Fizz');
//     } else if ((i % 5 === 0)) {
//         console.log('Buzz');
//     } else {
//         console.log(i);
//     }
// }

// -------------------------------------------------------

/**
 * ЗАВДАННЯ 2: Пошук простого числа
 * Напишіть код, який перевірить, чи є число 29 простим.
 * Просте число - це число, яке ділиться лише на 1 та на себе.
 * Ваша логіка має перевіряти, чи є у числа інші дільники.
 * Якщо ви знайдете хоча б один дільник, ви можете зупинити перевірку.
 *
 * Використайте цикл `for` та оператор `break`.
 */
// console.log("\n--- ЗАВДАННЯ 2: Пошук простого числа ---");
// const numberToCheck = 7;
// let isPrime = true;

// // варіант 1 (рахуємо від 2 бо будь яке число ділиться на 1 тоді умова if буде true і цикл завершиться)
// // i < numberToCheck (а не <=) тому що будь яке число ділиться на себе тоді умова if буде true і цикл завершиться
// for(let i = 2; i < numberToCheck; i++) {

//     if (numberToCheck % i === 0) {
//         isPrime = false;
//         break;
//     }
// }

// // варіант 2 (за допомогою функції Math.sqrt)
// // Перевіряти дільники достатньо лише до квадратного кореня числа. 
// // Наприклад, якщо число 100, то його дільники не можуть бути більшими за 50. 
// // корінь квадратий від числа 100 це 10 (тому що 10 * 10 = 100) тобто 2 * 10 = 20, 3*10 = 30 ... 10 * 10 = 100 - це не просте число
// // корінь квадратний від 7 це 2,64...., тобто нам досить перевірити лише чи 7 ділиться на 2
// // корінь квадратиний від 15 це 3,87..., ттобто нам досить перевірити чи 15 ділиться на 2 і на 3 без остачі - ділиться на 1 на 3 і на саме себе, тому 15 це не порсте число
// for(let i =2; i <= Math.sqrt(numberToCheck); i++) {

//     if (numberToCheck % i === 0) {
//         isPrime = false;
//         break;
//     }
// }


// if (isPrime) {
//   console.log(`${numberToCheck} - це просте число.`);
// } else {
//   console.log(`${numberToCheck} - це не просте число.`);
// }


// -------------------------------------------------------

/**
 * ЗАВДАННЯ 3: Обчислення факторіала
 * Напишіть цикл, який обчислить факторіал числа 5.
 * Факторіал числа - це добуток усіх натуральних чисел до цього числа включно (наприклад, 5! = 1 * 2 * 3 * 4 * 5).
 *
 * Використайте цикл `for`.
 */

// Варіант 1:
// console.log("\n--- ЗАВДАННЯ 3: Факторіал числа ---");
// const factorialNumber = 5;
// let factorialResult = 1;

// for (let i = 1; i <= factorialNumber; i++) {
//     factorialResult *= i;
// }


// console.log(`Факторіал числа ${factorialNumber} дорівнює ${factorialResult}.`); // Очікуваний результат: 120


// Варіант 2:
// console.log("\n--- ЗАВДАННЯ 3: Факторіал числа ---");
// const factorialNumber = 5;
// let factorialResult = 1;
// let factorialCounter = 1;

// while (factorialCounter <= factorialNumber) {
//     factorialResult *= factorialCounter;
//     factorialCounter++;
// }

// console.log(`Факторіал числа ${factorialNumber} дорівнює ${factorialResult}.`); // Очікуваний результат: 120

// -------------------------------------------------------

/**
 * ЗАВДАННЯ 4: Обробка введення до певного значення
 * Вам надано масив з числами, який симулює введення користувача.
 * Використайте цикл `while`, щоб обчислити суму всіх чисел у масиві.
 * Цикл має зупинитися, коли зустрінеться число 0.
 * Важливо: число 0 не повинно бути включене в загальну суму.
 *
 * Використайте цикл `while` та оператор `break`.
 */
// console.log("\n--- ЗАВДАННЯ 4: Обробка введення ---");
// const userInputs = [10, 5, 20, 8, 0, 15, 3];
// let currentSum = 0;
// let currentIndex = 0;

// while (currentIndex < userInputs.length) {
//     if (userInputs.at(currentIndex) === 0) {   // або (userInputs[currentIndex])
//         break;
//     }
//     currentSum += userInputs.at(currentIndex);
//     currentIndex++;
// }


// console.log(`Загальна сума чисел до 0: ${currentSum}.`); // Очікуваний результат: 43


// -------------------------------------------------------------------------------------------------------------

// Задача 1: Перевірка діапазону
// Напишіть скрипт, який перевіряє, чи знаходиться число num у діапазоні від 10 до 20 або від 40 до 50.
// Оголосіть змінну num = 15.
// Використайте логічні оператори && та || для перевірки обох діапазонів одночасно.
// Якщо умова істинна, виведіть "Число знаходиться в одному з діапазонів.".
// В іншому випадку виведіть "Число не знаходиться в жодному з діапазонів.".

// const num = 15;

// if ((num >= 10 && num <= 20) || (num >= 40 && num <= 50)) {
//     console.log('Число знаходиться в одному з діапазонів.');
// } else {
//     console.log('Число не знаходиться в жодному з діапазонів.');
// }

// -------------------------------------------------------------------------------------------------------------------

// Задача 2: Повнолітній, але не для алкоголю
// Напишіть скрипт, який:
// Оголошує змінну age = 21 та isClubMember = false.
// Перевіряє, чи є особа повнолітньою (старше 18), але не є членом клубу.
// Якщо умова істинна, виведіть "Доступ дозволено, але не можна купувати алкоголь.".
// В іншому випадку виведіть "Доступ заборонено або обмежено.".


// const age = 21;
// const isClubMember = false;

// if (age > 18 && !isClubMember) {
//     console.log('Доступ дозволено, але не можна купувати алкоголь.');
// } else {
//     console.log('Доступ заборонено або обмежено.');
// }


// -----------------------------------------------------------------------------------------------------------------------------------------

// Задача 3: Перевірка складних умов для входу
// Напишіть скрипт, який перевіряє, чи може користувач увійти на сайт.
// Умови для входу:
// Користувач має бути авторизований (isLoggedIn = true).
// І він має бути або адміністратором (isAdmin = true), або мати спеціальний токен (token = 'valid_token').
// Оголосіть змінні: isLoggedIn = true, isAdmin = false, token = 'invalid_token'.
// Використайте логічні оператори && та || для створення єдиної, складної умови.
// Якщо умова істинна, виведіть "Вхід успішний!".
// В іншому випадку виведіть "Недостатньо прав для входу.".


// const isLoggedIn = true;
// const isAdmin = false;
// const token = 'invalid_token';

// if (isLoggedIn && (isAdmin || token === 'valid_token')) {
//     console.log('Вхід успішний!');
// } else {
//     console.log('Недостатньо прав для входу.');
// }


// ----------------------------------------------------------------------------------------------------------------------------------------


// Задача 4: Погода та активність
// Напишіть скрипт, який допоможе визначити, чи варто йти гуляти.
// Умови:
// Температура має бути в межах від 15 до 25 градусів Цельсія (temperature = 20).
// І не має йти дощ (isRaining = false).
// АБО має бути вихідний день (isWeekend = true), незалежно від погоди.
// Оголосіть змінні: temperature = 20, isRaining = false, isWeekend = true.
// Створіть умову для перевірки всіх цих факторів.
// Якщо можна йти гуляти, виведіть "Чудовий день для прогулянки!".
// В іншому випадку виведіть "Залишаємось вдома.".

// const temperature = 20;
// const isRaining = false;
// const isWeekend = true;

// if (((temperature > 15 && temperature < 25) && !isRaining) || isWeekend) {
//     console.log('Чудовий день для прогулянки!');
// } else {
//     console.log('Залишаємось вдома.');
// }


// ---------------------------------------------------------------------------------------------------------------------------------------

// Задача 1: Перевірка віку та статус
// Напишіть код, який:
// Оголошує змінну age = 15.
// Використовує тернарний оператор, щоб присвоїти змінній message один з двох рядків:
// Якщо age менше 18, message має бути "Неповнолітній".
// Якщо age 18 або більше, message має бути "Повнолітній".
// Виводить message у консоль.
// Пограйтеся: Змініть age на 20 і перевірте, як зміниться результат.

// const age = 21;
// const message = age >= 18 ? 'Повнолітній' : 'Неповнолітній';
// console.log(message);

// ---------------------------------------------------------------------------------------------------------------------------------------

// Задача 2: Привітання з оцінкою
// Напишіть код, який:
// Оголошує змінну name = 'Олена' та grade = 88.
// Використовує тернарний оператор, щоб визначити, чи оцінка є прохідною. Вважайте, що прохідний бал — 70. Збережіть результат (наприклад, "пройшов" або "не пройшов") у змінній status.
// Використовує шаблонний літерал для створення повного речення, яке виводиться в консоль. Повідомлення має містити ім'я, оцінку та статус, наприклад:
// Вітаю, Олена! Ваша оцінка 88. Ви пройшли іспит.
// Пограйтеся: Змініть grade на 65 і подивіться, як зміниться повідомлення.

// const userName = 'Олена';
// const grade = 70;
// const gradeStatus = grade >= 70 ? 'пройшли' : 'не пройшли';

// console.log(`Вітаю, ${userName}! Ваша оцінка ${grade}. Ви ${gradeStatus} іспит!`);


// ----------------------------------------------------------------------------------------------------------------------------------------


// Задача 1: Перевірка права на знижку
// Напишіть код, який перевіряє, чи має клієнт право на знижку.
// Оголосіть змінні:
// isLoyaltyMember = true
// hasCoupon = false
// purchaseAmount = 150
// Використовуйте оператор if, щоб перевірити наступні умови:
// Клієнт є учасником програми лояльності (isLoyaltyMember) і сума покупки більша за 100.
// АБО клієнт має купон (hasCoupon).
// Якщо одна з умов істинна, використайте шаблонний літерал, щоб вивести в консоль: "Вітаємо! Ви отримуєте знижку!".
// В іншому випадку виведіть "На жаль, знижка не застосована.".

// const isLoyaltyMember = false;
// const hasCoupon = true;
// const purchaseAmount = 50;

// if ((isLoyaltyMember && purchaseAmount > 100) || hasCoupon) {
//     console.log(`Вітаємо! Ви отримуєте знижку`);
// } else {
//     console.log(`На жаль, знижка не застосована`);
// }

// ---------------------------------------------------------------------------------------------------------------------------------------------

// Задача 2: Статус користувача
// Напишіть код, який динамічно визначає статус користувача.
// Оголосіть змінні:
// isAdmin = false
// isModerator = true
// userName = 'Марина'
// Використовуйте тернарний оператор (можете вкладати один в одного, якщо потрібно), щоб присвоїти змінній userStatus один з трьох рядків: "Адміністратор", "Модератор" або "Звичайний користувач".
// Використайте шаблонний літерал, щоб вивести в консоль повідомлення, яке включає ім'я користувача та його статус. Наприклад: "Привіт, Марина! Ваш статус: Модератор.".


// const isAdmin = false;
// const isModerator = false;
// const userName = 'Марина';
// const userStatus = (isAdmin  ? 'Адміністратор' : isModerator ? 'Модератор' : 'Звичайний користувач');
// console.log(`Привіт, ${userName}! Ваш статус: ${userStatus}`);


// -----------------------------------------------------------------------------------------------------------------------------------------------

// Задача 3: Вітання до свята
// Напишіть код, який виводить вітання залежно від поточної дати.
// Оголосіть змінну today = 'Новий рік'.
// Використовуйте ланцюжок if...else if...else, щоб перевірити значення today і вивести відповідне вітання:
// Якщо today === 'Новий рік', виведіть: "З Новим роком!".
// Якщо today === 'Різдво', виведіть: "Веселого Різдва!".
// Якщо today === 'Великдень', виведіть: "Христос воскрес!".
// У всіх інших випадках виведіть: "Привіт, гарного дня!".
// Пограйтеся: Змініть значення today на "Різдво" та інші варіанти, щоб перевірити, як працює ваш код.


// const today = 'Різдво'

// if (today === 'Новий рік') {
//     console.log(`З Новим роком!`);
// } else if (today === 'Різдво') {
//     console.log(`Веселого Різдва!`);
// } else if (today === 'Великдень') {
//     console.log(`Христос Воскрес!`);
// } else {
//     console.log(`Привіт, гарного дня!`);
// }

// --------------------------------------------------------------------------------------------------------------------



// Завдання 1: Звичайна функція (Function Declaration)
// Створіть функцію з назвою isEven, яка приймає один параметр number. Функція повинна повертати true, якщо число парне, і false, якщо непарне.

// function isEven(number) {
//     return number % 2 === 0;
// }

// console.log(isEven(4));


// // рішення 2

// const isEven2 = number => number % 2 === 0;
// console.log(isEven2(7));


// Завдання 2: Вираз функції (Function Expression)
// Створіть функцію як вираз, що називається doubleNumber. Вона повинна приймати один параметр num та повертати його значення, помножене на 2.

// const doubleNumber = function(num) {
//     return num * 2;
// }
// console.log(doubleNumber(15));


// // рішення 2
// const doubleNumber2 = num => num * 2;
// console.log(doubleNumber2(6));


// Завдання 3: Стрілкова функція (Arrow Function)
// Перепишіть функцію з попереднього завдання як стрілкову. Назвіть її tripleNumber. Вона має приймати num та повертати його значення, помножене на 3.

// const tripleNumber = num => num * 3;
// console.log(tripleNumber(3));


// Завдання 4: Стрілкова функція з коротким записом
// Створіть стрілкову функцію getSquare, яка приймає один параметр x. Використайте короткий запис (без фігурних дужок та return), щоб функція повертала квадрат числа x.

// const getSquare = x => x * x;
// console.log(getSquare(5));

// Завдання 5: Значення за замовчуванням
// Створіть функцію greeting, яка приймає два параметри: name та message. Встановіть для message значення за замовчуванням 'Привіт!'. Функція повинна повертати рядок, що містить ім'я та повідомлення.

// const greeting = function (name, message = 'Привіт') {
//     return `${message}, ${name}!`
// }
// console.log(greeting('Анна'));


// Завдання 6: Значення за замовчуванням та стрілкова функція
// Створіть стрілкову функцію power, яка приймає base та exponent. Встановіть для exponent значення за замовчуванням 2. Функція має повертати base в степені exponent.

// const power = (base, exponent = 2) => base ** exponent;
// console.log(power(3, 3));


// Завдання 7: Вираз як значення за замовчуванням
// Створіть функцію logTime, яка приймає параметр time. Встановіть для time значення за замовчуванням, яке є результатом виклику функції getFormattedTime(). Функція logTime повинна просто виводити time в консоль.

// Ось допоміжна функція getFormattedTime():

// JavaScript

// function getFormattedTime() {
//   const now = new Date();
//   return `${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`;
// }


// const logTime = (time = getFormattedTime()) => time
// console.log(logTime());


// Завдання 8: Функція, що повертає іншу функцію
// Створіть функцію createMultiplier, яка приймає один параметр factor. Ця функція повинна повертати нову стрілкову функцію, яка, у свою чергу, приймає параметр number та повертає number помножений на factor.

// function createMultiplier(factor) {
//     const newNumber = number => number * factor;
//     return newNumber;
// }
// console.log(createMultiplier(10) (2));  // перший арг піде в зовішню функцію, 2 арг піде у внутрішню функцію


// додаткові варіанти з поясненням :
// /**
//  * Ця функція є "фабрикою" для інших функцій.
//  * Вона приймає "factor" і повертає нову функцію, яка буде множити
//  * будь-яке число на цей "factor".
//  *
//  * @param {number} factor - число, на яке будемо множити.
//  * @returns {function(number): number} - повертає нову функцію.
//  */
// function createMultiplier(factor) {
//     // Внутрішня функція, яка має доступ до "factor" з зовнішньої області видимості.
//     const newNumber = number => number * factor;
    
//     // Ми повертаємо саму функцію, а не результат її виконання.
//     return newNumber;
// }

// // Крок 1: Викликаємо зовнішню функцію `createMultiplier` і передаємо їй аргумент 5.
// // Вона повертає нову функцію, яка "запам'ятала" (через замикання)
// // що її "factor" дорівнює 5. Ми зберігаємо цю нову функцію у змінній.
// const multiplyBy5 = createMultiplier(5);

// // Крок 2: Тепер змінна `multiplyBy5` містить нашу "нову" функцію.
// // Ми можемо викликати її з іншим аргументом, наприклад, 10.
// // Вона виконає `10 * 5`.
// const result1 = multiplyBy5(10); // 50
// console.log(result1); // Виведе: 50

// // Крок 3: Ми можемо створити й інші множники з тим же кодом!
// // Наприклад, множник на 3.
// const multiplyBy3 = createMultiplier(3);
// const result2 = multiplyBy3(20); // 60
// console.log(result2); // Виведе: 60

// // Або ж можна зробити все в одному рядку (хоча це менш читабельно):
// // Спочатку викликаємо `createMultiplier(10)`
// // Отримаємо функцію, і одразу ж викликаємо її з аргументом 2.
// console.log(createMultiplier(10)(2)); // Виведе: 20





// Завдання 9: Комбінація функцій
// Створіть дві функції: add(a, b) та subtract(a, b). Кожна з них повинна повертати відповідний результат. Потім створіть функцію calculate(a, b, operation), яка приймає два числа та функцію-операцію як третій параметр. Викличте її для додавання та віднімання.



// function add(a, b) {
//     return a + b;
// }

// function substract(a, b) {
//     return a - b;
// }

// /**
//  * Performs the appropriate mathematical operation (+ or -)
//  * depending on the value of the operator parameter by calling
//  * the helper functions add or substract.
//  * @param {number} a - The first operand.
//  * @param {number} b - The second operand.
//  * @param {string} operator - The mathematical symbol for the operation ('+' or '-').
//  * @returns {number|string} The result of the operation or an error message.
//  */

// function calculate(a, b, operator) {

//     if (operator === '+') {
//         return add(a, b);
//     } else if (operator === '-') {
//         return substract(a, b)
//     } else {
//         return `Unexpected operator`
//     }

// }
// console.log(calculate(10, 5, '-'));


// Завдання 10: Функція з динамічною кількістю аргументів
// Створіть функцію sumAll, яка приймає необмежену кількість числових аргументів за допомогою оператора rest (...args). Функція повинна повертати суму всіх переданих чисел.

// /**
//  * @function sumAll
//  * Sums the unlimited quantity of arguments passed to a function
//  * @param  {...number} args - collection of numbers to be added
//  * @returns {number} Total sum of all arguments
//  */


// const sumAll = function (...args) {
//     let sum = 0;
//     for (const num of args) {
//         sum += num;
//     }
//     return sum;
// }

// console.log(sumAll(2, 2, 2, 2));

// -------------------------------------------------------------------------------------------------------------------------------------

// /**
//  * Ваше завдання: Додати повний JSDoc-коментар для цієї функції.
//  * Опишіть, що вона робить, які параметри приймає та що повертає.
//  */

// /**
//  * Function calculates the amount of discount
//  * @param {number} price - the clear price of product.
//  * @param {number} discountPercentage - the discount percentage
//  * @returns {number|string} - discounted price or error message
//  */
// function calculateDiscountedPrice(price, discountPercentage) {
//   // Розраховує ціну з урахуванням знижки
//   if (discountPercentage < 0 || discountPercentage > 100) {
//     return 'Invalid discount percentage';
//   }
//   const discountAmount = (price * discountPercentage) / 100;
//   return price - discountAmount;
// }

// // ---

// /**
//  * Ваше завдання: Документувати цей метод.
//  * Вкажіть, що це метод класу, та опишіть, що він повертає.
//  */


// class User {
//   constructor(firstName, lastName) {
//     this.firstName = firstName;
//     this.lastName = lastName;
//   }

//   /**
//    * @method getFullName
//    * @returns {string} full user name composed of two properties
//    */
//   getFullName() {
//     // Повертає повне ім'я користувача (ім'я та прізвище)
//     return `${this.firstName} ${this.lastName}`;
//   }
// }

// // ---

// /**
//  * Ваше завдання: Додати JSDoc до асинхронної функції.
//  * Опишіть її призначення, що вона повертає (проміс), та які можуть виникнути помилки.
//  */

// /**
//  * Fetches user data from a remote source.
//  * @async
//  * @param {string} userId - The unique identifier of the user.
//  * @returns {Promise<object>} - A Promise that resolves with a user data object on success.
//  * @throws {Error} If the request fails or data is unavailable.
//  */
// async function fetchUserData(userId) {
//   const isAvailable = Math.random() > 0.5;
//   if (!isAvailable) {
//     throw new Error('User data is currently unavailable.');
//   }

//   // Імітує запит до API та повертає дані користувача
//   return {
//     id: userId,
//     name: 'Jane Doe',
//     email: 'jane.doe@example.com'
//   };
// }

// // ---

// /**
//  * Ваше завдання: Документувати цю функцію та її параметр-коллбек.
//  * Поясніть, що `callback` очікує два аргументи: `item` та `index`.
//  */

// /**
//  * This callback is invoked for each item in an array.
//  * @callback ItemProcessor
//  * @param {*} item - The current array item.
//  * @param {number} index - The index of the current item.
//  * @param {Array<*>} array - The original array.
//  */

// /**
//  * Iterates over an array and applies a callback function to each element.
//  * @param {Array<*>} arr - The array to be processed.
//  * @param {ItemProcessor} callback - The function to be called for each item.
//  */
// function processArrayWithCallback(arr, callback) {
//   // Проходить по масиву та для кожного елемента викликає коллбек-функцію
//   for (let i = 0; i < arr.length; i++) {
//     callback(arr[i], i);
//   }
// }


// --------------------------------------------------------------------------------------------------------------------------



// Завдання 1: Основи об'єктів
// Створіть об'єкт книга з властивостями назва, автор і рік. Призначте їм довільні значення.
// Виведіть увесь об'єкт у консоль.
// Змініть значення властивості рік на нове.
// Додайте нову властивість жанр до об'єкта.
// Видаліть властивість автор з об'єкта.
// Виведіть фінальний стан об'єкта книга у консоль.


// const book = {
//     name: 'Harry Potter',
//     author: 'J.K.Rowling',
//     year: 1991
// }

// console.log(book);

// book.year = 1992;
// book.genre = 'fantasy';

// delete book.author;
// console.log(book);


// ------------------------------------------------------------------------------------------------------------------------------------------

// Завдання 2: Поверхневе копіювання
// Створіть об'єкт телефон з властивостями бренд, модель і характеристики, де характеристики — це вкладений об'єкт з властивостями пам'ять і колір.
// Створіть поверхневу копію об'єкта телефон і назвіть її телефон_копія. Використайте для цього оператор розширення (...) або Object.assign().
// Змініть властивість модель у телефон_копія.
// Змініть властивість пам'ять у вкладеному об'єкті характеристики в телефон_копія.
// Виведіть обидва об'єкти (телефон та телефон_копія) у консоль і поясніть, чому зміни, внесені в характеристики копії, вплинули на оригінал.

// const phone = {
//     brand: 'Samsung',
//     model: 'Galaxy A24',
//     characteristics: {
//         memory: '128 GB',
//         color: 'olive'
//     }
// }

// const phoneCopy = Object.assign({}, phone);

// phoneCopy.model = 'Galaxy A25';

// phoneCopy.characteristics.memory = '132 GB';

// console.log(phone);
// console.log(phoneCopy);

// Зміни внесені в характеристики копї телефона вплинули і на оригінал, тому що за допомогою Object.assign ми зробили Shallow copy яка копіює обєкт не враховуючи вкладення, тобто перший шар властивостей. Вкладені властивості всеодно залишаються посиланнями на оригінальний обєкт. Для того щоб цього уникнути при потрібно робити глибоке копіювання обєкту (до якого ми дійдемо пізніше)

// ------------------------------------------------------------------------------------------------------------------------------------------------

// Завдання 3: Робота з масивами об'єктів
// Створіть масив користувачі, що містить щонайменше два об'єкти. Кожен об'єкт повинен мати властивості ім'я та id.
// Використайте метод масиву, щоб знайти об'єкт, де id дорівнює 2, і збережіть його в окрему змінну.
// Змініть властивість ім'я у знайденому об'єкті.
// Виведіть оригінальний масив користувачі у консоль і поясніть, чому зміна в окремому об'єкті вплинула на об'єкт у масиві.


// const users = [
//     {
//      userName: 'Anna',
//      userId: 1
//     }, 
//     {
//      userName: 'Tonya',
//      userId: 2
//     }
// ];

// // Використовуємо метод .find(), щоб знайти об'єкт, у якого id дорівнює 2.
// // Зберігаємо знайдений об'єкт у змінну userToUpdate.
// // Метод .find() проходить по масиву, і для кожного елемента (користувача)
// // перевіряє, чи user.id === 2. Як тільки він знаходить перший збіг,
// // він повертає об'єкт і зупиняється.
// const userToUpdate = users.find(user => user.userId === 2);
// console.log(userToUpdate);

// // Змінюємо властивість 'name' у знайденому об'єкті.
// // Важливо: ми змінюємо властивість самого об'єкта, на який посилається змінна.
// if (userToUpdate) {
//     userToUpdate.userName = 'Petro';
// }

// console.log(users); // Anna  Petro
// // Об'єкти в JavaScript передаються не за значенням, а за посиланням.
// // Це означає, що коли ми використали метод .find() і зберегли результат
// // у змінну userToUpdate, ми не створили новий об'єкт-копію.
// // Натомість, змінна userToUpdate містить посилання (адресу в пам'яті)
// // на той самий об'єкт, що знаходиться всередині масиву users.
// // Тому, коли ми змінили властивість .name через змінну userToUpdate,
// // ми фактично змінили оригінальний об'єкт, який знаходиться в масиві.

// -------------------------------------------------------------------------------------------------------------------------------------------

// Завдання 4: Робота з каталогом товарів
// Інструкція:
// Створіть масив products, який містить принаймні три об'єкти. Кожен об'єкт повинен мати властивості name, id та price.
// Використайте метод масиву, щоб знайти об'єкт, у якого id дорівнює 3, і збережіть його в окрему змінну.
// Змініть властивість price у знайденому об'єкті, встановивши нове значення (наприклад, збільште його на 10%).
// Виведіть в консоль обидва значення: початковий масив products та окрему змінну зі знайденим об'єктом.
// Напишіть коротке пояснення, що ілюструє, чому зміна price в окремій змінній вплинула на оригінальний масив.

// const products = [
//     {
//         name: 'Anna',
//         id: 1,
//         price: 50
//     },
//     {
//         name: 'Tonya',
//         id: 2,
//         price: 75
//     },
//     {
//         name: 'Olya',
//         id: 3,
//         price: 98
//     },
// ];

// const userToUpdate = products.find(user => user.id === 3);

// if (userToUpdate) {
//     userToUpdate.price = userToUpdate.price + (userToUpdate.price * 10 / 100);
// }

// console.log(products);

// -------------------------------------------------------------------------------------------------------------------------------------------

// Завдання: Керування інвентаризацією
// Уявіть, що ви ведете список товарів на складі. Ваше завдання — створити JavaScript-код для виконання таких операцій:
// Створіть масив об'єктів inventory, де кожен об'єкт представляє товар і містить такі властивості:
// id (унікальний ідентифікатор, число)
// name (назва товару, рядок)
// quantity (кількість на складі, число)
// price (ціна за одиницю, число)
// Наповніть масив трьома-чотирма товарами на свій розсуд.
// Напишіть функцію updateQuantity(itemId, newQuantity), яка приймає id товару та нову кількість. Функція повинна знайти товар за id і оновити його кількість на нове значення. Якщо товар не знайдено, виведіть повідомлення в консоль, наприклад, "Товар з таким ID не знайдено."
// Викличте функцію updateQuantity для одного з товарів, щоб перевірити, як вона працює.
// Виведіть оновлений масив inventory у консоль, щоб переконатися, що зміни відбулися.


// const inventory = [
//     {
//         id: 1,
//         name: 'tomato',
//         quantity: 15,
//         price: 30
//     },
//     {
//         id: 2,
//         name: 'cucumber',
//         quantity: 84,
//         price: 20
//     },
//     {
//         id: 3,
//         name: 'cabage',
//         quantity: 56,
//         price: 18
//     },
//     {
//         id: 4,
//         name: 'eggplant',
//         quantity: 28,
//         price: 45
//     }
// ]

// const updateQuantity = function (itemId, newQuantity) {
//     // Шукаємо товар за його ID
//     const inventoryItem = inventory.find(item => item.id === itemId);

//     // Перевіряємо, чи був знайдений товар
//     if (inventoryItem) {
//         // Якщо товар знайдено, оновлюємо його кількість
//         inventoryItem.quantity = newQuantity;
//         console.log(`Кількість товару "${inventoryItem.name}" оновлено до ${newQuantity}.`);
//     } else {
//         // Якщо товар не знайдено, виводимо повідомлення про помилку
//         console.log(`Помилка: Товар з ID ${itemId} не знайдено.`);
//     }
// };

// updateQuantity(4, 36);
// console.log(inventory);

// --------------------------------------------------------------------------------------------------------------------------------------------------


// Ми маємо масив об'єктів users, де кожен об'єкт представляє користувача з його ID, ім'ям та списком куплених товарів (purchases). Ваша мета — написати функцію calculateTotalSpent, яка буде:
// Приймати userId як аргумент.
// Знаходити відповідного користувача в масиві users.
// Використовуючи метод reduce(), розраховувати загальну суму, витрачену цим користувачем на всі його покупки.
// Повертати цю загальну суму.
// Якщо користувача з таким ID не знайдено, функція повинна повертати 0.

// const users = [
//     {
//         id: 1,
//         name: 'Олег',
//         purchases: [
//             { item: 'книга', price: 250 },
//             { item: 'ручка', price: 15 },
//             { item: 'зошит', price: 40 }
//         ]
//     },
//     {
//         id: 2,
//         name: 'Олена',
//         purchases: [
//             { item: 'пазл', price: 120 },
//             { item: 'іграшка', price: 220 }
//         ]
//     },
//     {
//         id: 3,
//         name: 'Іван',
//         purchases: [
//             { item: 'футболка', price: 300 }
//         ]
//     }
// ];



// const calculateTotalSpent = function (userId) {

//     // 1. Знайдіть користувача за його ID
//     // Використайте метод .find()
//     let currentUser = users.find(user => user.id === userId);

//     // 2. Якщо користувача не знайдено, поверніть 0
//     if (!currentUser) {
//         return 0;
//     }

//     // 3. Використайте метод .reduce() для розрахунку загальної суми
//     // Не забудьте про початкове значення для reduce(), яке тут дорівнює 0
//     const totalSum = currentUser.purchases.reduce((accum, purchase) => {
//         // На кожній ітерації додаємо ціну покупки до накопичувача
//         return accum + purchase.price;
//     }, 0); // Початкове значення акумулятора

//     return totalSum;
    
// }

// console.log(`Загальні витрати Олега: ${calculateTotalSpent(1)} грн.`); // Очікуваний результат: 305
// console.log(`Загальні витрати Олени: ${calculateTotalSpent(2)} грн.`); // Очікуваний результат: 340
// console.log(`Загальні витрати Івана: ${calculateTotalSpent(3)} грн.`); // Очікуваний результат: 300
// console.log(`Загальні витрати неіснуючого користувача: ${calculateTotalSpent(4)} грн.`); // Очікуваний результат: 0


// ---------------------------------------------------------------------------------------------------------------------------------------------


// У вас є об'єкт user, який представляє інформацію про користувача. Ваше завдання — написати функцію updateUser, яка:
// Прийматиме сам об'єкт user, ключ (наприклад, 'age') та нове значення для цього ключа.
// Оновлюватиме значення властивості в об'єкті за наданим ключем.
// Додаватиме нову властивість 'isVerified' зі значенням true.
// Повертатиме оновлений об'єкт.
// Спробуйте зробити це, не використовуючи методи масивів, а лише властивості об'єктів. Це допоможе вам краще зрозуміти, як працювати з об'єктами напряму.

// const user = {
//     name: 'Ірина',
//     age: 28,
//     city: 'Київ'
// };

// function updateUser (userObject, key, newValue) {
// // Щоб використовувати значення змінної як ім'я властивості, потрібно застосувати дужковий синтаксис (квадратні дужки []). 
// // Бо якщо я напишу userObject.key =  newValue; то до обєкту просто додасться нова властивість key з значенням 'Vinnitsya'
// // Тобто щоб key як змінну (парам функції) застосувати (а не як буквальну назву властивості треба квадратні дужки []
//     userObject[key] =  newValue;

//     userObject.isVerified = true;
//     return userObject;
// }

// updateUser(user, 'city', 'Vinnitsya');
// console.log(user);



// -----------------------------------------------------------------------------------------------------------------------------------------



// Задача: Видалення властивості
// Ця задача допоможе вам попрактикуватися у видаленні властивостей з об'єкта. Це базова операція, яка часто використовується на практиці.
// Ваше завдання — створити функцію removeProperty, яка:
// Приймає два параметри: userObject (об'єкт, з якого потрібно видалити властивість) і key (ім'я властивості, яку потрібно видалити).
// Видаляє властивість з userObject за допомогою ключа, що передається.
// Повертає оновлений об'єкт.

// const user = {
//     name: 'Ірина',
//     age: 28,
//     city: 'Київ'
// };

// function removeProperty (userObject, key) {
//     // додати перевірку, чи існує така властивість в об'єкті, перш ніж намагатися її видалити. Це робить функцію більш стійкою до помилок.
//     if (userObject.hasOwnProperty(key)) {
//         delete userObject[key];
//     }
//     return userObject;
// }

// // Коли ви звертаєтеся до ключа об'єкта, він має бути рядком (або Symbol), тому його потрібно взяти в лапки.
// console.log(removeProperty(user, 'age'));



// ----------------------------------------------------------------------------------------------------------------------------------------------------


// Напиши функцію JavaScript під назвою countWords, яка приймає один аргумент — рядок (string). Ця функція повинна повертати об'єкт, де ключами є слова з рядка, а значеннями — кількість їхніх повторень.
// Приклад:
// Якщо вхідний рядок такий: "Кіт і собака. Кіт — найкращий друг."
// Функція повинна повернути такий об'єкт:
// {
//   "кіт": 2,
//   "і": 1,
//   "собака": 1,
//   "найкращий": 1,
//   "друг": 1
// }
// Зверніть увагу на такі моменти:
// Слова повинні бути в нижньому регістрі.
// Розділові знаки (наприклад, крапка, кома, тире) не повинні бути частиною слів.

// function countWords (string) {

//     // Створюємо об'єкт для зберігання результатів.
//     const wordsObj = {}

//     // розділити стрінг на слова в масив
//     // Очищаємо рядок від розділових знаків, переводимо в нижній регістр
//     // і ділимо на окремі слова, використовуючи регулярний вираз.
//     // Регулярний вираз `/[a-zA-Zа-яА-Я0-9]+/g` шукає послідовності літер та цифр.
//     // Добре працює на англ.мові але не відпрацьовує правильно на укр.
//     const wordsArr = string.toLowerCase().match(/[a-zA-Zа-яА-Я0-9]+/g);
//     console.log(wordsArr);

//     //      // ще один варіант для англ. мови але не працює для укр мови
//     //     // Регулярний вираз `/\W+/g` розділяє рядок за будь-якими символами, що не є "словами".
//     //     const wordsArr = text.toLowerCase().split(/\W+/g).filter(Boolean);

//     // Якщо масив пустий (наприклад, рядок був порожній), повертаємо пустий об'єкт.
//     if (!wordsArr) {
//         return wordsObj;
//     }

//     // пройтись по масиву і пошукати однакові слова
//     // Крок 2: Підрахунок слів
//     // Проходимося по кожному слову в масиві.
//     for (const word of wordsArr) {
//         // Перевіряємо, чи вже існує це слово як ключ в нашому об'єкті.
//         // Це можна зробити за допомогою `wordsObj[word]`. Якщо ключа немає,
//         // його значення буде `undefined`, що в умовах `if` буде трактуватися як `false`.
//         if (wordsObj[word]) {
//             // Якщо слово вже є, збільшуємо його значення на 1.
//             wordsObj[word]++;
//         } else {
//             // Якщо слова ще немає, додаємо його в об'єкт
//             // і присвоюємо йому початкове значення 1.
//             wordsObj[word] = 1;
//         }
//     }

//     // Крок 3: Повернення результату
//     // Повертаємо готовий об'єкт.
//     return wordsObj;
// }


// const text2 = 'If I love you, you love me!';
// console.log(countWords(text2));

// // Тестуємо функцію з прикладом:
// const text = 'Кіт і собака. Кіт — найкращий друг.';
// console.log(countWords(text));

// // Тестуємо з іншим рядком, щоб переконатися, що все працює правильно:
// const anotherText = 'Мене тут немає, для тебе мене теж немає';
// console.log(countWords(anotherText));



// //  Складніший варіант рішення щоб правильно оброблялась і українська і англійська мовва

// /**
//  * Функція, що рахує повторення слів у рядку.
//  * Ця версія є більш надійною, оскільки не залежить від складних регулярних виразів.
//  * @param {string} text - Вхідний рядок, який потрібно обробити.
//  * @returns {Object} Об'єкт, де ключами є слова, а значеннями - кількість їхніх повторень.
//  */
// function countWords(text) {
//     // Крок 1: Підготовка
//     // Створюємо об'єкт для зберігання результатів.
//     const wordsObj = {};

//     // Очищаємо рядок від розділових знаків (замінюємо розділові знаки на пробіли які потім відріжем) та переводимо в нижній регістр.
//     // Регулярний вираз `/[.,—?!]/g` видаляє такі знаки пунктуації.
//     const cleanedText = text.toLowerCase().replace(/[.,—?!]/g, ' ');

//     // Розділяємо рядок на окремі слова, використовуючи пробіли як роздільник і для кожного слова видаляєм зайві пробіли на початку та кінці слова.
//     const wordsArr = cleanedText.split(' ').filter(word => word.trim() !== '');

//     // Якщо масив пустий, повертаємо пустий об'єкт.
//     if (!wordsArr || wordsArr.length === 0) {
//         return wordsObj;
//     }

//     // Крок 2: Підрахунок слів
//     // Проходимося по кожному слову в масиві.
//     for (const word of wordsArr) {
//         // Перевіряємо, чи слово вже існує як ключ в нашому об'єкті.
//         // Використовуємо .trim() на всякий випадок, щоб прибрати зайві пробіли.
//         const trimmedWord = word.trim();
//         if (trimmedWord.length > 0) {
//             if (wordsObj[trimmedWord]) {
//                 // Якщо слово вже є, збільшуємо його значення на 1.
//                 wordsObj[trimmedWord]++;
//             } else {
//                 // Якщо слова ще немає, додаємо його в об'єкт
//                 // і присвоюємо йому початкове значення 1.
//                 wordsObj[trimmedWord] = 1;
//             }
//         }
//     }

//     // Крок 3: Повернення результату
//     // Повертаємо готовий об'єкт.
//     return wordsObj;
// }

// // Тестуємо функцію з прикладом:
// const text = 'Кіт і собака. Кіт — найкращий друг.';
// console.log(countWords(text));
// // Очікуваний результат: { 'кіт': 2, 'і': 1, 'собака': 1, 'найкращий': 1, 'друг': 1 }

// // Тестуємо з іншим рядком:
// const anotherText = 'Мене тут немає, для тебе мене теж немає: я зв"язана!';
// console.log(countWords(anotherText));
// // Очікуваний результат: { 'мене': 2, 'тут': 1, 'немає': 2, 'для': 1, 'тебе': 1, 'теж': 1 }


// --------------------------------------------------------------------------------------------------------------------


// Задача 1: Створення об'єктів для бібліотеки
// Завдання: Напиши функцію-конструктор Book, яка буде створювати об'єкти з трьома властивостями:
// title (назва книги)
// author (автор)
// year (рік видання)
// Потім створи два екземпляри об'єкта Book з довільними даними.

// function Book (title, author, year) {
//     this.title = title;
//     this.author = author;
//     this.year = year;
// }

// const book1 = new Book ('Harry Potter', 'J.K.Rowling', 1991);
// const book2 = new Book ('Harry Potter2', 'J.K.Rowling', 1992);

// console.log(book1, book2);




// Задача 2: Додавання методів через prototype
// Завдання: Візьми функцію-конструктор Book із попередньої задачі. Додай до її прототипу (Book.prototype) метод getSummary, який буде повертати рядок у такому форматі: "Назва книги 'Назва' була написана автором 'Автор' у році 'Рік'.".
// Створи один екземпляр Book і виклич для нього цей метод.

// function Book (title, author, year) {
//     this.title = title;
//     this.author = author;
//     this.year = year;
// }

// Book.prototype.getSummary = function () {
//     return `Назва книги ${title} була написана автором ${author} у році ${year}.`
// }

// const book1 = new Book ('Harry Potter', 'J.K.Rowling', 1991);
// const book2 = new Book ('Harry Potter2', 'J.K.Rowling', 1992);

// console.log(book1.getSummary());
// console.log(book2.getSummary());

// console.log(book1, book2);


// Задача 3: Перевірка типу об'єкта
// Завдання: Створи функцію-конструктор Car з властивостями brand і model.
// Створи два об'єкти: один за допомогою new Car() та інший — звичайний об'єкт {}.
// За допомогою оператора instanceof перевір, чи обидва об'єкти є екземплярами Car, та виведи результат у консоль.


// function Car (brand, model) {
//     this.brand = brand;
//     this.model = model;
// }

// const car1 = new Car('Mazda', 'CX30');
// const car2 = {};
// const car3 = Car('BMW', 'X5');

// console.log(car1 instanceof Car);  // true
// console.log(car2 instanceof Car);  // false
// console.log(car3 instanceof Car);  // false

// console.log(car1);  // Car {brand: 'Mazda', model: 'CX30'}
// console.log(car2);  // {}
// console.log(car3);  // undefined




// Задача 1: Проста ієрархія
// Напиши функцію-конструктор Animal та іншу функцію-конструктор Dog. Зроби так, щоб Dog наслідував Animal. Потім створи об'єкт myDog за допомогою Dog і перевір, чи myDog є екземпляром обох Dog та Animal за допомогою instanceof. Поясни, чому обидві перевірки повертають true.

// function Animal () {
//     this.isMammal = true;
// }

// function Dog () {
//     // 1. Викликаємо конструктор батьківського класу (Animal)
//     // Це дозволяє скопіювати властивості Animal (наприклад, isMammal) в наш новий об'єкт Dog.
//     Animal.call(this);
//     this.name = 'Dog';

// }

// // 2. Встановлюємо ланцюжок прототипів
// // Ми робимо прототипом Dog новий об'єкт, який є екземпляром Animal.
// // Це і створює правильний зв'язок для instanceof.
// Dog.prototype = new Animal();

// // 3. Важливо! Відновлюємо властивість конструктора
// // Оскільки ми замінили прототип, нам потрібно вказати, хто є справжнім конструктором для Dog.
// Dog.prototype.constructor = Dog;


// const dog1 = new Dog();
// console.log(dog1 instanceof Dog);
// console.log(dog1 instanceof Animal);
// console.log(dog1.isMammal);
// Зверни увагу, конструктор Animal викликається двічі:
// один раз для створення прототипу (Dog.prototype = new Animal()),
// і один раз для створення самого об'єкта (Animal.call(this)).
// Це особливість старого прототипного наслідування.



// Задача 2: Розуміння динамічних змін
// Дано наступний код. Подумай, що виведеться в консоль.
// JavaScript
// function Employee(name) {
//   this.name = name;
// }
// const employee1 = new Employee('Іван');
// // Додаємо прототип 'Manager'
// function Manager() {}
// Manager.prototype = employee1;
// const manager1 = new Manager();
// console.log(manager1 instanceof Manager);
// console.log(manager1 instanceof Employee);
// Поясни, чому результат саме такий. Зверни увагу на те, як динамічно змінюється ланцюжок прототипів.


// обєкт manager1 є інстансом Manager
// прототип обєкта manager1 є тим самим обєктом що й  Manager.prototype який посислається на employee1 який є інстансом Employee який є його прототипом.
// manager1 → Manager.prototype → Employee.prototype(через employee1 який сам поо собі не є частиною ланцюжка, а лише мостом для зєднання прототипів Manager і Employee).

// та ж 2 задача лиш з наслідуванням (а не лише прототипом ланцюжків)
// function Employee(name) {
//   this.name = name;
// }
// const employee1 = new Employee('Іван');
// // Додаємо прототип 'Manager'
// function Manager(name) {
//         Employee.call(this, name);
// }
// Manager.prototype = new Employee();
// Manager.prototype.constructor =  Manager;
// const manager1 = new Manager('Марія');
// console.log(manager1 instanceof Manager);
// console.log(manager1 instanceof Employee);
// console.log(manager1.name);
// console.log(employee1.name);



// Задача 3: instanceof та символи
// Згенеруй код, який створить два об'єкти: obj1 та obj2. Додай до obj1 спеціальний символ Symbol.hasInstance, який змусить instanceof повертати true для obj2, навіть якщо вони не мають жодного зв'язку.
// Ця задача покаже, як можна контролювати поведінку instanceof за допомогою символів, що є більш просунутою темою.

// // Створюємо перший об'єкт, який буде "псевдо-конструктором"
// const obj1 = {
//   // Додаємо спеціальний символ Symbol.hasInstance
//   // Це метод, який викликається, коли об'єкт знаходиться справа від instanceof
//   [Symbol.hasInstance](instance) {
//     // Цей метод повертає true, якщо об'єкт, що перевіряється (instance),
//     // відповідає певним умовам. У нашому випадку, ми просто завжди повертаємо true
//     // для демонстрації.
//     console.log("Виконується метод Symbol.hasInstance для перевірки.");
//     return true; 
//   }
// };

// // Створюємо другий об'єкт, який буде перевірятися
// const obj2 = {};

// console.log("Перевіряємо чи 'obj2' є екземпляром 'obj1' за допомогою instanceof.");

// // Зазвичай, ця перевірка повернула б false,
// // оскільки obj2 не є екземпляром obj1
// const isInstance = obj2 instanceof obj1;

// console.log(`Результат перевірки: ${isInstance}`); 

// // Перевірка показує true, хоча об'єкти не мають зв'язку,
// // що демонструє роботу Symbol.hasInstance.

// ---
// // У цьому коді ви побачите, що коли `instanceof` виконує перевірку, він спочатку шукає наявність 
// // символу `Symbol.hasInstance` на об'єкті, що знаходиться праворуч. Якщо він його знаходить, то викликає метод,
// //  визначений цим символом. Це дозволяє нам повністю контролювати, що буде повертати `instanceof`.




// Задача 1: Створення об'єкта "Студент"
// Створіть функцію-конструктор з назвою Student. Ця функція повинна приймати два аргументи: name (ім'я студента) та grade (його клас або курс).
// Кожен об'єкт, створений за допомогою new Student(...), повинен мати дві властивості: name і grade.
// Після цього створіть два об'єкти-студенти, наприклад, "Іван" (5-й клас) та "Марія" (7-й клас), і виведіть їх властивості в консоль.


// function Student(name, grade) {
//     this.name = name;
//     this.grade = grade;
// }

// const student1 = new Student ('Іван', 5);
// const student2 = new Student ('Марія', 7);

// console.log(student1, student2);






// Задача 2: Додавання методів за допомогою прототипу
// На основі попередньої задачі, додайте новий метод до конструктора Student.
// Метод повинен називатися sayHello і виводити в консоль рядок у форматі: "Привіт, мене звати [ім'я студента] і я навчаюся у [клас студента] класі."
// Підказка: Пам'ятайте, що методи краще додавати до прототипу конструктора (Student.prototype), щоб вони не дублювалися для кожного об'єкта, що заощадить пам'ять.
// Створіть новий об'єкт Student та викличте його метод sayHello.

// function Student(name, grade) {
//     this.name = name;
//     this.grade = grade;
// }

// Student.prototype.sayHello = function() {
//     console.log(`Привіт, мене звати ${this.name} і я навчаюся у ${this.grade} класі.`);
// }

// const student1 = new Student('Іван', 5);
// const student2 = new Student('Марія', 7);

// console.log(student1, student2);

// student1.sayHello();


// ------------------------------------------------------------------------------------------------------------------------------------------

// Задача 1: Ініціалізація та доступ
// Створіть масив під назвою фрукти, який містить три рядки: "яблуко", "банан" та "апельсин".
// Виведіть у консоль другий елемент масиву (банан).
// Замініть перший елемент (яблуко) на "ківі".
// Виведіть у консоль весь масив, щоб переконатися у змінах.

// const fruits = ['apple', 'banana', 'orange'];
// console.log(fruits[1]);
// fruits[0] = 'kiwi';
// console.log(fruits);


// Задача 2: Довжина масиву та останній елемент
// Створіть масив числа з п'яти довільних цілих чисел.
// Виведіть у консоль загальну кількість елементів у масиві.
// Використовуючи властивість length, виведіть у консоль останній елемент масиву.

// const numbers = [1, 15, 108, 24, 66];
// console.log(numbers.length);
// console.log(numbers[numbers.length - 1]);



// Задача 3: Простий перебір за допомогою for
// Створіть масив кольори з трьома рядками: "червоний", "зелений", "синій".
// Використовуючи цикл for, переберіть масив і виведіть кожен елемент у консоль.

// const colors = ['red', 'green', 'blue'];

// // for (let color = 0; color <= colors.length - 1; color++) {
// //     console.log(colors[color]);
// // }

// for (const color of colors) {
//     console.log(color);
// }


// Задача 4: Перебір за допомогою for...of
// Створіть масив тварини з кількома назвами тварин.
// Використовуючи цикл for...of, переберіть масив і виведіть у консоль кожну назву тварини.

// const animals = ['dog', 'cat', 'mouse', 'parrot'];

// for (const animal of animals) {
//     console.log(animal);
// }


// Задача 5: Обчислення суми елементів
// Створіть масив ціни з довільними числами.
// Використовуючи цикл for, обчисліть суму всіх елементів масиву.
// Збережіть суму в змінну загальнаСума.
// Виведіть у консоль загальнаСума разом із пояснювальним текстом, наприклад: "Загальна сума цін: <сума>".

// const prices = [105, 215, 98, 32];
// let totalSum = 0;

// for (const price of prices) {

//     totalSum += price;

// }
// console.log(`Total sum of prices is ${totalSum}`);



// Завдання 6
// Напишіть код, який об'єднає два масиви в один і виведе його у консоль.
// Масив 1: ['apple', 'banana', 'orange']
// Масив 2: ['grape', 'kiwi']


// const fruits1 = ['apple', 'banana', 'orange'];
// const fruits2 = ['grape', 'kiwi'];

// const fruits = [...fruits1, ... fruits2];

// fruits1[0] = 'avocado';
// console.log(fruits1);
// console.log(fruits);



// Завдання 7
// Напишіть код, який перевірить, чи є число парним, чи непарним.
// Якщо число парне — виведіть у консоль повідомлення "Число парне.", якщо непарне — "Число непарне.".
// Число для перевірки: 42

// const number = 42;

// if (number % 2 === 0) {
//     console.log(`${number} is an even number`);
// } else {
//     console.log(`${number} is an odd number`);
// }


// Завдання 8
// Напишіть код, який знайде найдовше слово у масиві.
// Масив для перевірки: ['apple', 'banana', 'kiwi', 'pineapple', 'grape'];


// const fruits = ['apple', 'banana', 'kiwi', 'pineapple', 'grape'];
// let longestName = '';

// for (const fruit of fruits) {

//     if (fruit.length > longestName.length) {
//         longestName = fruit;
//     }
// }

// console.log(longestName);




// Завдання 9
// Створіть код, який перетворить кожну літеру кожного слова в масиві на велику.
// Масив для перетворення: ['hello', 'world', 'in', 'javascript']
// Очікуваний результат: ['HELLO', 'WORLD', 'IN', 'JAVASCRIPT']


// const words = ['hello', 'world', 'in', 'javascript'];
// const wordsUpperCase = [];

// for (const word of words) {
//     // тут я в підкладаю слова в новий масив за тим самим індексом за яким вони знаходились в старому масиві
//     // (отримуючи індекс поточного елемента під час ітерації по старому масиву)
//     wordsUpperCase[words.indexOf(word)] = word.toUpperCase(); 

// }

// console.log(wordsUpperCase);



// Завдання 10
// Створіть код, який видалить перший та останній елементи з масиву.
// Масив для обробки: ['apple', 'banana', 'kiwi', 'pineapple', 'grape']
// Очікуваний результат: ['banana', 'kiwi', 'pineapple']

// // варіант 1
// let fruits = ['apple', 'banana', 'kiwi', 'pineapple', 'grape'].slice(1, -1);
// console.log(fruits);


// // варіант 2
// const fruits = ['apple', 'banana', 'kiwi', 'pineapple', 'grape'];
// const newFruits = [];

// // Проходимося по масиву, починаючи з другого елемента (індекс 1)
// // і зупиняємося перед останнім елементом (fruits.length - 1)
// for (let i = 1; i < fruits.length - 1; i++) {
//     newFruits.push(fruits[i]);
// }

// console.log(newFruits);


// варіант 3
// const fruits = ['apple', 'banana', 'kiwi', 'pineapple', 'grape'];

// // Розраховуємо довжину нового масиву
// const newLength = fruits.length - 2;
// // Створюємо новий порожній масив
// const newFruits = new Array(newLength);

// // Проходимося по елементах від індексу 1 до передостаннього
// for (let i = 0; i < newLength; i++) {
//     // Присвоюємо елементи з оригінального масиву
//     // (починаючи з індексу 1) до нового масиву
//     newFruits[i] = fruits[i + 1];
// }

// console.log(newFruits);




// Завдання 11
// Створіть код, який додасть новий елемент banana на початок масиву та новий елемент grape в кінець масиву.
// Масив для обробки: ['apple', 'kiwi', 'pineapple']
// Очікуваний результат: ['banana', 'apple', 'kiwi', 'pineapple', 'grape']

// 1 варіант
// const fruits = ['apple', 'kiwi', 'pineapple'];
// fruits.unshift('banana');
// fruits.push('grape');

// console.log(fruits);

// 2 варіант
// const fruits = ['apple', 'kiwi', 'pineapple'];
// const fruits2 = ['banana', ...fruits, 'grape'];
// console.log(fruits2);


// 3 варіант
// const fruits = ['apple', 'kiwi', 'pineapple'];
// const fruitsAddition = ['banana', 'grape'];
// const fruits2 = [fruitsAddition[0], ...fruits, fruitsAddition[1]];
// console.log(fruits2);




// 1. Збільшення віку
// Створіть поверхневу копію масиву users. Потім за допомогою циклу for...of або методу forEach збільшіть значення age на 1 
// для кожного об'єкта в новій копії. Виведіть обидва масиви в консоль, щоб переконатися, що оригінальний масив залишився без змін.

// const users = [
//   { name: 'Alice', age: 25 },
//   { name: 'Bob', age: 30 },
//   { name: 'Charlie', age: 35 }
// ];

// const usersCopy = [...users];
// for (user of usersCopy) {
//     user.age = user.age + 1;
// }

// console.log(usersCopy);
// console.log(users);  // зміняться одидва масиви, тому що я зробила лише поверхневу копію, а зміни вносила нв шар глибше

// 2. Подвоєння чисел
// Створіть поверхневу копію масиву numbers. Переберіть елементи в новій копії та за допомогою методу map створіть новий масив,
//  в якому кожне число буде помножене на 2. Виведіть обидва масиви, щоб переконатися, що оригінал не змінився.


// const numbers = [1, 2, 3, 4, 5];
// const numbersCopy = [...numbers].map(num => num * 2);
// const numbersCopy2 = Array.from(numbers).map(num => num * 3);

// console.log(numbers);
// console.log(numbersCopy);
// console.log(numbersCopy2);




// 3. Фільтрування та копіювання
// Створіть поверхневу копію масиву products. Використовуючи метод filter, створіть новий масив expensiveProducts, 
// що містить лише продукти, ціна яких більша за 100. Переконайтеся, що оригінальний масив products не змінився.


// const products = [
//   { name: 'Laptop', price: 1200 },
//   { name: 'Mouse', price: 25 },
//   { name: 'Keyboard', price: 75 },
//   { name: 'Monitor', price: 300 }
// ];

// const expensiveProducts = Array.from(products).filter(item => item.price > 100);

// console.log(expensiveProducts);
// console.log(products);


// 4. Зміна статусу
// Створіть поверхневу копію масиву tasks. Переберіть елементи в новій копії та змініть значення completed на true для всіх завдань. 
// Переконайтеся, що оригінальний масив залишився без змін.

// const tasks = [
//   { id: 1, text: 'Вивчити JavaScript', completed: false },
//   { id: 2, text: 'Написати код', completed: false },
//   { id: 3, text: 'Перевірити завдання', completed: false }
// ];

// const completedTasks = tasks.map(task => {
//   // Перевіряємо, чи завдання вже виконане.
//   if (task.completed === true) {
//     // Якщо так, повертаємо його копію без змін.
//     return { ...task };

//     //якщо не  задати тут else, то якщо task.completed вже true, if-блок не виконається, 
//     // і функція повертає undefined. У результаті, completedTasks буде містити undefined для таких елементів.
//     // тому шо map() повинене виконати якусь операцію з кожним елементом, а функція повинна повертати щось інакше поверне undefined
//     // і цей undefined замінить ті елементи які мали completed: true в початковому масиві
//   } else {
//     // Якщо ні, створюємо нову копію і змінюємо властивість completed.
//     return { ...task, completed: true };
//   }
// });

// console.log(completedTasks);




// 5. Об'єднання та сортування
// Створіть поверхневу копію масиву a, об'єднавши його з масивом b. Потім відсортуйте новий об'єднаний масив в порядку зростання.
//  Виведіть обидва оригінальних масиви та новий об'єднаний масив. Переконайтеся, що a та b не були змінені.


// const a = [5, 2, 8];
// const b = [1, 9, 3, 10];
// const aB = [...a, ...b].sort(function (a, b) {
//     return a - b
// });


// console.log(aB);
// console.log(aB2);

// [5, 2, 8, 1, 9, 3, 10]
// 5 - 2  = 3
// [2, 5, 8, 1, 9, 3, 10]
// 5 - 8 = -3
// [2, 5, 8, 1, 9, 3, 10]
// 8 - 1 = 7
// 5 - 1 = 4
// 2 - 1 = 1
// [1, 2, 5, 8, 9, 3, 10].
// 9 - 3 = 6
// 8 - 3 = 5
// 5 - 3 = 2
// 2 - 3 = -1
// [1, 2, 3, 5, 8, 9, 10]
// 9 - 10 = -1
// [1, 2, 3, 5, 8, 9, 10]


// ['a', 'b', 'c'].slice(1, 2)

