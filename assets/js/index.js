
// Задачі
// Ось кілька задач різного рівня складності, які поєднують обидві теми. Спробуйте розв'язати їх самостійно.

// Задача 1: Простий калькулятор (if...else if...else)
// Створіть невеликий скрипт, який:

// Оголошує три змінні: a = 10, b = '5', operator = '+'.
// Перевіряє значення змінної operator за допомогою конструкції if...else if...else.
// Якщо operator дорівнює '+', виводить в консоль суму a та b.
// Якщо operator дорівнює '-', виводить різницю a та b.
// Якщо operator дорівнює '*', виводить добуток a та b.
// В іншому випадку (блок else), виводить повідомлення "Невідомий оператор".
// Важливо: зверніть увагу на те, як JavaScript обробляє операції з рядком '5'. Чи потрібно перетворювати його на число?

// const a = 10,
//       b = '5',
//       operator = '*';

// if (operator === '+') {
//     console.log(+a + +b);   // тут для універсальності перетворюю значення кожної змінної в число за доопмогою унарного оператора +  в кожній гілці перед тим як обчислювати
// } else if (operator === '-') {
//     console.log(+a - +b);   // тут для універсальності перетворюю значення кожної змінної в число за доопмогою унарного оператора +  в кожній гілці перед тим як обчислювати
// } else if (operator === '*') {
//     console.log(+a * +b);   // тут для універсальності перетворюю значення кожної змінної в число за доопмогою унарного оператора +  в кожній гілці перед тим як обчислювати
// } else {
//     console.log('Unknown operator');
// }


// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



// Задача 2: Перевірка оцінки (if...else)
// Створіть скрипт, який:

// Оголошує змінну grade і присвоює їй рядок '75'.
// Використовуючи конструкцію if...else, перевіряє, чи є оцінка (змінна grade) прохідною. Припустимо, що прохідний бал — 60 або більше.
// Якщо умова істинна, виводить в консоль "Прохідний бал.".
// Якщо умова хибна, виводить "Непрохідний бал.".
// Важливо: щоб порівняння спрацювало коректно, вам доведеться явно перетворити рядок grade на число.

// const grade = '75';

// if (Number(grade) >= 60) {    // явне перетворення типу в число для уникнення несподіванок через глобальну функцію Number
//     console.log('Passing grade!');
// } else {
//     console.log('Not a passing grade');
// }

// Причина, чому grade.toNumber() не працює, полягає в тому, що toNumber() не є стандартним методом для примітивного типу даних string (рядків) у JavaScript.
// Коли ви оголошуєте const grade = '75';, grade є просто рядком. Рядкові значення мають багато вбудованих методів (наприклад, length, toUpperCase(), substring() тощо), але вони не мають методу toNumber().


// та ж задача з використанням тернароного оператора мій варіант:
// const resultGrade = Number(grade) >= 60 ? console.log('Passing grade!') : console.log('Not a passing grade');

// та ж задача з використанням тернарного оператора виправлений варіант Gemini (з поясненням):
//зазвичай тернарний оператор використовується для присвоєння значення змінній на основі умови, а не для виконання побічних ефектів (як console.log).
// Наприклад, більш типовим використанням було б:
// const message = Number(grade) >= 60 ? 'Passing grade!' : 'Not a passing grade';
// console.log(message);
//У вашому випадку resultGrade отримає значення, яке повертає console.log() (а це undefined), але сам console.log() все одно виконається. Це не помилка, але це не найпоширеніший спосіб використання тернарного оператора.


// -------------------------------------------------------------------------------------------------------------------------------------------------------

// Задача 3: Вік у рядку (if)
// Створіть скрипт, який:

// Оголошує змінну ageText і присвоює їй значення '25'.
// Використовує умовний оператор if для перевірки, чи є вік, вказаний у змінній ageText, більшим за 18.
// Якщо умова істинна, виводить "Доступ дозволено.".
// Важливо: переконайтеся, що ви явно перетворюєте рядок на число перед порівнянням, щоб уникнути помилок.

// const ageText = '25';

// if (+ageText > 18) {   // явне перетворення в число за допомогою унарного оператора +
//     console.log('Access allowed');
// }


// ---------------------------------------------------------------------------------------------------------------------------------


// Задача 1: Перевірка статусу замовлення
// Напишіть скрипт, який:

// Оголошує змінну orderStatus і присвоює їй рядок 'pending'.
// Оголошує змінну hasShipped і присвоює їй логічне значення false.
// Використовує конструкцію if...else if...else для перевірки статусу:
// Якщо orderStatus дорівнює 'completed', виводить в консоль "Замовлення виконано.".
// Якщо orderStatus дорівнює 'pending' І hasShipped є false, виводить "Замовлення очікує відправки.".
// В іншому випадку виводить "Статус замовлення невідомий або відправлено.".
// Пограйтеся: Спробуйте змінити значення orderStatus на 'completed' або hasShipped на true, щоб побачити, як змінюється вивід.


// const orderStatus = 'pending';
// const hasShipped = false;

// if (orderStatus === 'completed') {
//     console.log('Order completed');
// } else if (orderStatus === 'pending' && hasShipped === false) {
//     console.log('Order is waiting for sending');
// } else {
//     console.log('Unknown or shipped order status');
// }


// -------------------------------------------------------------------------------------------------------------------------------------



// Задача 2: Порівняння чисел з різними типами
// Створіть скрипт, який:

// Оголошує дві змінні: num1 = 100 (число) та num2 = '100' (рядок).
// Використовує умовний оператор if для перевірки, чи num1 дорівнює num2 за допомогою оператора ==. Виведіть відповідне повідомлення.
// Використовує інший умовний оператор if для перевірки, чи num1 суворо дорівнює num2 за допомогою оператора ===. Виведіть відповідне повідомлення.
// Поясніть у коментарях до коду, чому результати цих двох порівнянь відрізняються (або не відрізняються).


// const num1 = 100, 
//       num2 = '100';

// if (num1 == num2) {  // поверне true через неявне приведення типів, де рядок '100' перетворюється на число 100 перед порівнянням.
//     console.log('Не строге порівняння!');
// }

// if (num1 === num2) {  // поверне false, оскільки суворе порівняння перевіряє не тільки значення, але й тип даних, і в цьому випадку number не дорівнює string
//     console.log('Строге порівняння');
// }


// --------------------------------------------------------------------------------------------------------------------------------------------

// Задача 3: Доступ до сайту за віком та дозволом
// Напишіть скрипт, який:

// Оголошує змінну userAge і присвоює їй рядок '17'.
// Оголошує змінну hasPermission і присвоює їй рядок 'true' (саме рядок).
// Використовує умовний оператор if з логічним оператором && (І) для перевірки двох умов:
// userAge має бути більшим або дорівнювати 18.
// hasPermission має бути істинним (тобто, перетвореним на булеве true).
// Якщо обидві умови істинні, виводить "Доступ до сайту дозволено.".
// В іншому випадку (використовуючи else), виводить "Доступ до сайту заборонено.".
// Підказка: Не забудьте про приведення типів для userAge та hasPermission перед їх використанням в умовах.

// const userAge = '21',
//       hasPermission = 'true';

// if (+userAge >= 18 && hasPermission === 'true') {
//     console.log('Access to web-site is allowed');
// } else {
//     console.log('Access to web-site is not allowed');
// }

// console.log(Boolean(hasPermission));


// Пояснення Gemini чому Boolean(hasPermission) та !!hasPermission не працюють 
// оператор !!  та глобальна функція Boolean() перетворює значення на булевий тип, ґрунтуючись на тому, чи є воно "truthy" або "falsy". Будь-який не порожній рядок (включно з 'true', 'false', 'hello') є "truthy". Тому !!'true' завжди повертатиме true, оскільки рядок 'true' сам по собі не є порожнім.
// Однак, коли ви використовуєте Boolean(), ви явно вказуєте JavaScript, що хочете отримати булеве значення. У випадку з рядками, якщо ви хочете перетворити рядок 'true' на булеве true, а рядок 'false' на булеве false, вам потрібно буде зробити це вручну або за допомогою умовної логіки, оскільки Boolean('false') теж поверне true (бо рядок 'false' не порожній і є "truthy").
// Ваша змінна hasPermission має значення 'true' (рядок). Якщо ви хочете, щоб вона стала булевим true саме тому, що її вміст є рядком "true", а не просто тому, що вона не порожня, вам потрібно буде порівняти її вміст
// hasPermission === 'true'


// --------------------------------------------------------------------------------------------------------------------------------

// Задача 1: Загальний доступ
// Створіть скрипт, який:

// Оголошує дві змінні: isLoggedIn = true та hasPermission = false.
// Використовуючи оператор &&, перевіряє, чи є користувач авторизованим і чи має він дозвіл.
// Якщо умова істинна, виводить "Доступ дозволено.".
// В іншому випадку виводить "Доступ заборонено.".
// Пограйтеся: Спробуйте змінити значення змінних, щоб побачити, як це впливає на результат.

// const isLoggedIn = true,
//       hasPermission = false;

// if (isLoggedIn && hasPermission) {  // якщо isLoggedIn true та hasPermission true то доступ дозволено
//     console.log('Доступ дозволено!');
// } else {
//     console.log('Доступ заборонено!');
// }

// -------------------------------------------------------------------------------------------------------------------


// Задача 2: Вільний час
// Напишіть скрипт, який:

// Оголошує дві змінні: isWeekend = true та isHoliday = false.
// Використовуючи оператор ||, перевіряє, чи сьогодні вихідний або святковий день.
// Якщо умова істинна, виводить "Можна відпочивати.".
// В іншому випадку виводить "Час працювати.".

// const isWeekend = true,
//       isHoliday = false;

// if (isWeekend || isHoliday) {  // якщо isWeekend true або isHoliday true (один з них) то Можна відпочивати
//     console.log('Мона відпочивати');
// } else {
//     console.log('Час працювати');
// }


// --------------------------------------------------------------------------------------------------------------------------

// Задача 3: Складний пароль
// Напишіть скрипт, який:

// Оголошує змінну password = 'Pa$$w0rd'.
// Оголошує дві змінні, які будуть перевіряти певні умови: hasUpperCase = false та hasSpecialChar = true.
// Використовує логічний оператор && для перевірки, чи довжина пароля більша за 8 символів і чи містить він великі літери (hasUpperCase) і чи містить він спеціальні символи (hasSpecialChar).
// Якщо всі умови істинні, виводить "Пароль надійний.".
// В іншому випадку виводить "Пароль не надійний.".
// Підказка: Використовуйте вбудовану властивість length для рядків, щоб отримати довжину пароля.

// const password = 'Pa$$w0rd';
// const hasUpperCase = false,
//       hasSpecialChar = true;

// if (password.length > 8 && hasUpperCase && hasSpecialChar) {  // якщо всі(кожна) умови true то пароль надійний
//     console.log('Пароль надійний!');
// } else {
//     console.log('Пароль не надійний!');
// }


// ---------------------------------------------------------------------------------------------------------------------

// Задача 1: Перевірка права на знижку
// Створіть скрипт, який:

// Оголошує змінні: isMember = false, orderTotal = 150 та isFirstTimeCustomer = true.
// Використовуючи комбінацію логічних операторів, перевіряє умову для отримання знижки:
// Знижку отримує клієнт, який є учасником програми (isMember) або сума його замовлення (orderTotal) більша за 100 і він є новим клієнтом (isFirstTimeCustomer).
// Якщо умова істинна, виводить "Клієнт має право на знижку.".
// В іншому випадку виводить "Клієнт не має права на знижку.".
// Підказка: Будьте уважні до порядку виконання операцій. Якщо потрібно, використовуйте круглі дужки.

// const isMember = false;
// const orderTotal = 150;
// const isFirstTimeCostumer = true;

// if (isMember || (orderTotal > 100 && isFirstTimeCostumer)) {  // якщо isMember true або (orderTotal > 100 та isFirstTimeCostumer true) клієнт має знижку
//     console.log('Клієнт має право на знижку.');
// } else {
//     console.log('Клієнт не має права на знижку.');
// }


// Задача 2: Визначення назви користувача (коротке замикання)
// Створіть скрипт, який:

// Оголошує змінні: userLoggedIn = null та defaultUser = 'Гість'.
// Використовує логічний оператор || для присвоєння значення змінній currentUsername.
// Якщо userLoggedIn має значення, currentUsername має отримати це значення.
// Якщо userLoggedIn є "falsy" (наприклад, null), currentUsername має отримати значення defaultUser.
// Виведіть значення currentUsername в консоль.
// Пограйтеся: Спробуйте змінити userLoggedIn на рядок, наприклад 'Іван'. Як це вплине на результат завдяки механізму "короткого замикання"?

// варіант 1 з if...else
// const userLoggedIn = undefined;
// const defaultUser = 'Гість';
// let currentUsername = '';

// if (userLoggedIn) {
//     currentUsername = userLoggedIn;
// } else {
//     currentUsername = defaultUser;
// }
// console.log(currentUsername);

//варіант 2 з логічним оператором ||

// const userLoggedIn = null;
// const defaultUser = 'Гість';
// let currentUsername = userLoggedIn || defaultUser;  // currentUsername буде = ім'я (якщо воно є в userLoggedIn) або Гість (якщо в userLoggedIn нема імені)
// console.log(currentUsername);

// -------------------------------------------------------------------------------------------------------------------------------------------------------------

// Задача 3: Доступ до вмісту
// Напишіть скрипт, який:

// Оголошує змінні: userRole = 'admin', isSubscriptionActive = false та isBetaTester = true.
// Використовує комбінацію && та || для перевірки доступу:
// Доступ дозволено, якщо користувач має роль 'admin' АБО його підписка активна (isSubscriptionActive) І він є бета-тестером (isBetaTester).
// Якщо доступ дозволено, виводить "Доступ до секретного контенту дозволено.".
// В іншому випадку виводить "Доступ заборонено.".
// Підказка: Ретельно продумайте, як згрупувати умови, щоб логіка відповідала завданню.


// const userRole = 'AdmiN';
// const isSubscriptionActive = false;
// const isBetaTester = true;

// if (userRole.toLocaleLowerCase() === 'admin' || (isSubscriptionActive && isBetaTester)) {
//     console.log('Доступ до секретного контенту дозволено.');
// } else {
//     console.log('Доступ заборонено.');
// }

// ----------------------------------------------------------------------------------------------------------------------------


// Задача 1: Вхід у систему
// Створіть скрипт, який перевіряє можливість входу користувача.
// Оголосіть змінні: username = 'user', password = 'password123', isUserActive = true.
// Напишіть умову, яка перевіряє:
// Логін — 'user' І пароль — 'password123' І користувач активний.
// Якщо всі умови істинні, виведіть "Вхід успішний.".
// В іншому випадку виведіть "Помилка входу.".
// Пограйтеся: Спробуйте змінити значення однієї зі змінних, щоб побачити, як це впливає на результат.

// const userName = 'User';
// const password = 'password123';
// const isUserActive = true;

// if (userName.toLowerCase() === 'user' && password === 'password123' && isUserActive) {
//     console.log('Вхід успішний.');
// } else {
//     console.log('Помилка входу.');
// }

// ----------------------------------------------------------------------------------------------------------------------

// Задача 2: Доступ до преміум-контенту
// Напишіть скрипт, який перевіряє доступ до преміум-контенту.
// Оголосіть змінні: isPremium = true, hasCoupon = false, orderPrice = 90.
// Використайте комбінацію логічних операторів для перевірки:
// Користувач має доступ, якщо він є преміум-користувачем АБО він має купон ТА сума його замовлення більша за 100.
// Якщо умова істинна, виведіть "Доступ до преміум-контенту дозволено.".
// В іншому випадку виведіть "Доступ заборонено.".
// Пограйтеся: Спробуйте змінити значення змінних, щоб перевірити різні сценарії.

// const isPremium = true;
// const hasCoupon = false;
// const orderPrice = 90;

// if (isPremium || (hasCoupon && orderPrice > 100)) {
//     console.log('Доступ до преміум-контенту дозволено.');
// } else {
//     console.log('Доступ заборонено.');
// }

// ---------------------------------------------------------------------------------------------------------------


// Задача 3: Перевірка наявності даних
// Напишіть скрипт, який використовує "коротке замикання" для перевірки наявності даних.
// Оголосіть змінні: userName = 'Іван', userEmail = '', userPhone = 0.
// Використайте логічний оператор && для перевірки, чи є всі три змінні truthy.
// Якщо всі три змінні є truthy, виведіть "Всі дані наявні.".
// В іншому випадку, виведіть "Недостатньо даних.".
// Підказка: Не використовуйте явне порівняння === true.

// const userName = 'Іван';
// const userEmail = '';
// const userPhone = 0;

// if (userName && userEmail && userPhone) {
//     console.log('Всі дані наявні.');
// } else {
//     console.log('Недостатньо даних.');
// }


// --------------------------------------------------------------------------------------------------------------------------


/**
 * ЗАВДАННЯ 1: Цикл `for` та оператор `if`
 * Наша попередня розмова була про добуток чисел від -5 до 10.
 * Тут є аналогічне завдання, але з іншим діапазоном.
 * Порахуйте суму всіх цілих чисел у діапазоні від -3 до 7,
 * але пропустіть число 0. Використайте цикл `for` та оператор `if`.
 * Після виконання, виведіть результат у консоль.
 */
// let sum = 0;

// for (let i = -3; i <= 7; i++) {
//   if (i === 0) {
//     continue;
//   }
//   sum += i;
// }

// console.log("Результат завдання 1 (сума): ", sum); // Очікуваний результат: 22


// -------------------------------------------------------

/**
 * ЗАВДАННЯ 2: Цикл `while`
 * Створіть змінну `i` зі значенням 5.
 * Використайте цикл `while`, щоб віднімати 1 від `i` на кожній ітерації.
 * Цикл має виконуватись, поки `i` не стане меншим або дорівнюватиме 0.
 * Всередині циклу виведіть поточне значення `i`.
 */
// let i = 5;

// while(i > 0) {
//     console.log(i);
//     i -= 1;
// }

// console.log("Результат завдання 2: цикл завершено.");


// -------------------------------------------------------

/**
 * ЗАВДАННЯ 3: Цикл `do...while`
 * Цей цикл завжди виконується хоча б один раз.
 * Створіть змінну `x` зі значенням 10.
 * Використайте цикл `do...while` так, щоб він виконав блок коду
 * один раз, навіть якщо умова `x < 5` не виконується з самого початку.
 * У тілі циклу виведіть `x` та потім відніміть від нього 1.
 */
// let x = 10;
// do {
//     console.log(x);
//     x--;
// } while (x < 5)

// console.log("Результат завдання 3: цикл завершено.");


// -------------------------------------------------------

/**
 * ЗАВДАННЯ 4: `break`
 * Використайте цикл `for`, щоб перебирати числа від 1 до 100.
 * Як тільки ви знайдете перше число, яке ділиться на 17 без залишку,
 * виведіть його в консоль і негайно зупиніть цикл за допомогою `break`.
 */
// for (let i = 1; i <= 100; i++) {
//     if (i % 17 === 0) {
//         console.log(i);
//         break;
//     }
// }

// console.log("Результат завдання 4: цикл завершено."); // Очікуваний результат: 17


// -------------------------------------------------------

/**
 * ЗАВДАННЯ 5: `continue`
 * Використайте цикл `for` для виведення чисел від 1 до 20.
 * Але за допомогою оператора `continue` пропустіть всі парні числа
 * (ті, що діляться на 2 без залишку).
 * Тобто, в консолі мають бути лише непарні числа.
 */
// for (let i = 1; i <= 20; i++) {
//     if (i % 2 === 0) {
//         continue;
//     }
//     console.log(i);
// }

// console.log("Результат завдання 5: цикл завершено.");



/**
 * ЗАВДАННЯ 1: Задача "FizzBuzz"
 * Напишіть цикл, який перебирає числа від 1 до 100.
 * Для кожного числа, виконайте наступні умови:
 * 1. Якщо число ділиться на 3 без залишку, виведіть "Fizz".
 * 2. Якщо число ділиться на 5 без залишку, виведіть "Buzz".
 * 3. Якщо число ділиться і на 3, і на 5 без залишку, виведіть "FizzBuzz".
 * 4. В усіх інших випадках просто виведіть саме число.
 *
 * Використайте цикл `for` та умовні оператори `if...else if...else`.
 */
// console.log("--- ЗАВДАННЯ 1: FizzBuzz ---");

// for (let i = 1; i <= 100; i++) {
//     if (i % 3 === 0 && (i % 5 === 0)) {
//         console.log('FizzBuzz');
//     } else if (i % 3 === 0) {
//         console.log('Fizz');
//     } else if ((i % 5 === 0)) {
//         console.log('Buzz');
//     } else {
//         console.log(i);
//     }
// }

// -------------------------------------------------------

/**
 * ЗАВДАННЯ 2: Пошук простого числа
 * Напишіть код, який перевірить, чи є число 29 простим.
 * Просте число - це число, яке ділиться лише на 1 та на себе.
 * Ваша логіка має перевіряти, чи є у числа інші дільники.
 * Якщо ви знайдете хоча б один дільник, ви можете зупинити перевірку.
 *
 * Використайте цикл `for` та оператор `break`.
 */
// console.log("\n--- ЗАВДАННЯ 2: Пошук простого числа ---");
// const numberToCheck = 7;
// let isPrime = true;

// // варіант 1 (рахуємо від 2 бо будь яке число ділиться на 1 тоді умова if буде true і цикл завершиться)
// // i < numberToCheck (а не <=) тому що будь яке число ділиться на себе тоді умова if буде true і цикл завершиться
// for(let i = 2; i < numberToCheck; i++) {

//     if (numberToCheck % i === 0) {
//         isPrime = false;
//         break;
//     }
// }

// // варіант 2 (за допомогою функції Math.sqrt)
// // Перевіряти дільники достатньо лише до квадратного кореня числа. 
// // Наприклад, якщо число 100, то його дільники не можуть бути більшими за 50. 
// // корінь квадратий від числа 100 це 10 (тому що 10 * 10 = 100) тобто 2 * 10 = 20, 3*10 = 30 ... 10 * 10 = 100 - це не просте число
// // корінь квадратний від 7 це 2,64...., тобто нам досить перевірити лише чи 7 ділиться на 2
// // корінь квадратиний від 15 це 3,87..., ттобто нам досить перевірити чи 15 ділиться на 2 і на 3 без остачі - ділиться на 1 на 3 і на саме себе, тому 15 це не порсте число
// for(let i =2; i <= Math.sqrt(numberToCheck); i++) {

//     if (numberToCheck % i === 0) {
//         isPrime = false;
//         break;
//     }
// }


// if (isPrime) {
//   console.log(`${numberToCheck} - це просте число.`);
// } else {
//   console.log(`${numberToCheck} - це не просте число.`);
// }


// -------------------------------------------------------

/**
 * ЗАВДАННЯ 3: Обчислення факторіала
 * Напишіть цикл, який обчислить факторіал числа 5.
 * Факторіал числа - це добуток усіх натуральних чисел до цього числа включно (наприклад, 5! = 1 * 2 * 3 * 4 * 5).
 *
 * Використайте цикл `for`.
 */

// Варіант 1:
// console.log("\n--- ЗАВДАННЯ 3: Факторіал числа ---");
// const factorialNumber = 5;
// let factorialResult = 1;

// for (let i = 1; i <= factorialNumber; i++) {
//     factorialResult *= i;
// }


// console.log(`Факторіал числа ${factorialNumber} дорівнює ${factorialResult}.`); // Очікуваний результат: 120


// Варіант 2:
// console.log("\n--- ЗАВДАННЯ 3: Факторіал числа ---");
// const factorialNumber = 5;
// let factorialResult = 1;
// let factorialCounter = 1;

// while (factorialCounter <= factorialNumber) {
//     factorialResult *= factorialCounter;
//     factorialCounter++;
// }

// console.log(`Факторіал числа ${factorialNumber} дорівнює ${factorialResult}.`); // Очікуваний результат: 120

// -------------------------------------------------------

/**
 * ЗАВДАННЯ 4: Обробка введення до певного значення
 * Вам надано масив з числами, який симулює введення користувача.
 * Використайте цикл `while`, щоб обчислити суму всіх чисел у масиві.
 * Цикл має зупинитися, коли зустрінеться число 0.
 * Важливо: число 0 не повинно бути включене в загальну суму.
 *
 * Використайте цикл `while` та оператор `break`.
 */
// console.log("\n--- ЗАВДАННЯ 4: Обробка введення ---");
// const userInputs = [10, 5, 20, 8, 0, 15, 3];
// let currentSum = 0;
// let currentIndex = 0;

// while (currentIndex < userInputs.length) {
//     if (userInputs.at(currentIndex) === 0) {   // або (userInputs[currentIndex])
//         break;
//     }
//     currentSum += userInputs.at(currentIndex);
//     currentIndex++;
// }


// console.log(`Загальна сума чисел до 0: ${currentSum}.`); // Очікуваний результат: 43


// -------------------------------------------------------------------------------------------------------------

// Задача 1: Перевірка діапазону
// Напишіть скрипт, який перевіряє, чи знаходиться число num у діапазоні від 10 до 20 або від 40 до 50.
// Оголосіть змінну num = 15.
// Використайте логічні оператори && та || для перевірки обох діапазонів одночасно.
// Якщо умова істинна, виведіть "Число знаходиться в одному з діапазонів.".
// В іншому випадку виведіть "Число не знаходиться в жодному з діапазонів.".

// const num = 15;

// if ((num >= 10 && num <= 20) || (num >= 40 && num <= 50)) {
//     console.log('Число знаходиться в одному з діапазонів.');
// } else {
//     console.log('Число не знаходиться в жодному з діапазонів.');
// }

// -------------------------------------------------------------------------------------------------------------------

// Задача 2: Повнолітній, але не для алкоголю
// Напишіть скрипт, який:
// Оголошує змінну age = 21 та isClubMember = false.
// Перевіряє, чи є особа повнолітньою (старше 18), але не є членом клубу.
// Якщо умова істинна, виведіть "Доступ дозволено, але не можна купувати алкоголь.".
// В іншому випадку виведіть "Доступ заборонено або обмежено.".


// const age = 21;
// const isClubMember = false;

// if (age > 18 && !isClubMember) {
//     console.log('Доступ дозволено, але не можна купувати алкоголь.');
// } else {
//     console.log('Доступ заборонено або обмежено.');
// }


// -----------------------------------------------------------------------------------------------------------------------------------------

// Задача 3: Перевірка складних умов для входу
// Напишіть скрипт, який перевіряє, чи може користувач увійти на сайт.
// Умови для входу:
// Користувач має бути авторизований (isLoggedIn = true).
// І він має бути або адміністратором (isAdmin = true), або мати спеціальний токен (token = 'valid_token').
// Оголосіть змінні: isLoggedIn = true, isAdmin = false, token = 'invalid_token'.
// Використайте логічні оператори && та || для створення єдиної, складної умови.
// Якщо умова істинна, виведіть "Вхід успішний!".
// В іншому випадку виведіть "Недостатньо прав для входу.".


// const isLoggedIn = true;
// const isAdmin = false;
// const token = 'invalid_token';

// if (isLoggedIn && (isAdmin || token === 'valid_token')) {
//     console.log('Вхід успішний!');
// } else {
//     console.log('Недостатньо прав для входу.');
// }


// ----------------------------------------------------------------------------------------------------------------------------------------


// Задача 4: Погода та активність
// Напишіть скрипт, який допоможе визначити, чи варто йти гуляти.
// Умови:
// Температура має бути в межах від 15 до 25 градусів Цельсія (temperature = 20).
// І не має йти дощ (isRaining = false).
// АБО має бути вихідний день (isWeekend = true), незалежно від погоди.
// Оголосіть змінні: temperature = 20, isRaining = false, isWeekend = true.
// Створіть умову для перевірки всіх цих факторів.
// Якщо можна йти гуляти, виведіть "Чудовий день для прогулянки!".
// В іншому випадку виведіть "Залишаємось вдома.".

// const temperature = 20;
// const isRaining = false;
// const isWeekend = true;

// if (((temperature > 15 && temperature < 25) && !isRaining) || isWeekend) {
//     console.log('Чудовий день для прогулянки!');
// } else {
//     console.log('Залишаємось вдома.');
// }


// ---------------------------------------------------------------------------------------------------------------------------------------

// Задача 1: Перевірка віку та статус
// Напишіть код, який:
// Оголошує змінну age = 15.
// Використовує тернарний оператор, щоб присвоїти змінній message один з двох рядків:
// Якщо age менше 18, message має бути "Неповнолітній".
// Якщо age 18 або більше, message має бути "Повнолітній".
// Виводить message у консоль.
// Пограйтеся: Змініть age на 20 і перевірте, як зміниться результат.

// const age = 21;
// const message = age >= 18 ? 'Повнолітній' : 'Неповнолітній';
// console.log(message);

// ---------------------------------------------------------------------------------------------------------------------------------------

// Задача 2: Привітання з оцінкою
// Напишіть код, який:
// Оголошує змінну name = 'Олена' та grade = 88.
// Використовує тернарний оператор, щоб визначити, чи оцінка є прохідною. Вважайте, що прохідний бал — 70. Збережіть результат (наприклад, "пройшов" або "не пройшов") у змінній status.
// Використовує шаблонний літерал для створення повного речення, яке виводиться в консоль. Повідомлення має містити ім'я, оцінку та статус, наприклад:
// Вітаю, Олена! Ваша оцінка 88. Ви пройшли іспит.
// Пограйтеся: Змініть grade на 65 і подивіться, як зміниться повідомлення.

// const userName = 'Олена';
// const grade = 70;
// const gradeStatus = grade >= 70 ? 'пройшли' : 'не пройшли';

// console.log(`Вітаю, ${userName}! Ваша оцінка ${grade}. Ви ${gradeStatus} іспит!`);


// ----------------------------------------------------------------------------------------------------------------------------------------


// Задача 1: Перевірка права на знижку
// Напишіть код, який перевіряє, чи має клієнт право на знижку.
// Оголосіть змінні:
// isLoyaltyMember = true
// hasCoupon = false
// purchaseAmount = 150
// Використовуйте оператор if, щоб перевірити наступні умови:
// Клієнт є учасником програми лояльності (isLoyaltyMember) і сума покупки більша за 100.
// АБО клієнт має купон (hasCoupon).
// Якщо одна з умов істинна, використайте шаблонний літерал, щоб вивести в консоль: "Вітаємо! Ви отримуєте знижку!".
// В іншому випадку виведіть "На жаль, знижка не застосована.".

// const isLoyaltyMember = false;
// const hasCoupon = true;
// const purchaseAmount = 50;

// if ((isLoyaltyMember && purchaseAmount > 100) || hasCoupon) {
//     console.log(`Вітаємо! Ви отримуєте знижку`);
// } else {
//     console.log(`На жаль, знижка не застосована`);
// }

// ---------------------------------------------------------------------------------------------------------------------------------------------

// Задача 2: Статус користувача
// Напишіть код, який динамічно визначає статус користувача.
// Оголосіть змінні:
// isAdmin = false
// isModerator = true
// userName = 'Марина'
// Використовуйте тернарний оператор (можете вкладати один в одного, якщо потрібно), щоб присвоїти змінній userStatus один з трьох рядків: "Адміністратор", "Модератор" або "Звичайний користувач".
// Використайте шаблонний літерал, щоб вивести в консоль повідомлення, яке включає ім'я користувача та його статус. Наприклад: "Привіт, Марина! Ваш статус: Модератор.".


// const isAdmin = false;
// const isModerator = false;
// const userName = 'Марина';
// const userStatus = (isAdmin  ? 'Адміністратор' : isModerator ? 'Модератор' : 'Звичайний користувач');
// console.log(`Привіт, ${userName}! Ваш статус: ${userStatus}`);


// -----------------------------------------------------------------------------------------------------------------------------------------------

// Задача 3: Вітання до свята
// Напишіть код, який виводить вітання залежно від поточної дати.
// Оголосіть змінну today = 'Новий рік'.
// Використовуйте ланцюжок if...else if...else, щоб перевірити значення today і вивести відповідне вітання:
// Якщо today === 'Новий рік', виведіть: "З Новим роком!".
// Якщо today === 'Різдво', виведіть: "Веселого Різдва!".
// Якщо today === 'Великдень', виведіть: "Христос воскрес!".
// У всіх інших випадках виведіть: "Привіт, гарного дня!".
// Пограйтеся: Змініть значення today на "Різдво" та інші варіанти, щоб перевірити, як працює ваш код.


// const today = 'Різдво'

// if (today === 'Новий рік') {
//     console.log(`З Новим роком!`);
// } else if (today === 'Різдво') {
//     console.log(`Веселого Різдва!`);
// } else if (today === 'Великдень') {
//     console.log(`Христос Воскрес!`);
// } else {
//     console.log(`Привіт, гарного дня!`);
// }

// --------------------------------------------------------------------------------------------------------------------



// Завдання 1: Звичайна функція (Function Declaration)
// Створіть функцію з назвою isEven, яка приймає один параметр number. Функція повинна повертати true, якщо число парне, і false, якщо непарне.

// function isEven(number) {
//     return number % 2 === 0;
// }

// console.log(isEven(4));


// // рішення 2

// const isEven2 = number => number % 2 === 0;
// console.log(isEven2(7));


// Завдання 2: Вираз функції (Function Expression)
// Створіть функцію як вираз, що називається doubleNumber. Вона повинна приймати один параметр num та повертати його значення, помножене на 2.

// const doubleNumber = function(num) {
//     return num * 2;
// }
// console.log(doubleNumber(15));


// // рішення 2
// const doubleNumber2 = num => num * 2;
// console.log(doubleNumber2(6));


// Завдання 3: Стрілкова функція (Arrow Function)
// Перепишіть функцію з попереднього завдання як стрілкову. Назвіть її tripleNumber. Вона має приймати num та повертати його значення, помножене на 3.

// const tripleNumber = num => num * 3;
// console.log(tripleNumber(3));


// Завдання 4: Стрілкова функція з коротким записом
// Створіть стрілкову функцію getSquare, яка приймає один параметр x. Використайте короткий запис (без фігурних дужок та return), щоб функція повертала квадрат числа x.

// const getSquare = x => x * x;
// console.log(getSquare(5));

// Завдання 5: Значення за замовчуванням
// Створіть функцію greeting, яка приймає два параметри: name та message. Встановіть для message значення за замовчуванням 'Привіт!'. Функція повинна повертати рядок, що містить ім'я та повідомлення.

// const greeting = function (name, message = 'Привіт') {
//     return `${message}, ${name}!`
// }
// console.log(greeting('Анна'));


// Завдання 6: Значення за замовчуванням та стрілкова функція
// Створіть стрілкову функцію power, яка приймає base та exponent. Встановіть для exponent значення за замовчуванням 2. Функція має повертати base в степені exponent.

// const power = (base, exponent = 2) => base ** exponent;
// console.log(power(3, 3));


// Завдання 7: Вираз як значення за замовчуванням
// Створіть функцію logTime, яка приймає параметр time. Встановіть для time значення за замовчуванням, яке є результатом виклику функції getFormattedTime(). Функція logTime повинна просто виводити time в консоль.

// Ось допоміжна функція getFormattedTime():

// JavaScript

// function getFormattedTime() {
//   const now = new Date();
//   return `${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`;
// }


// const logTime = (time = getFormattedTime()) => time
// console.log(logTime());


// Завдання 8: Функція, що повертає іншу функцію
// Створіть функцію createMultiplier, яка приймає один параметр factor. Ця функція повинна повертати нову стрілкову функцію, яка, у свою чергу, приймає параметр number та повертає number помножений на factor.

// function createMultiplier(factor) {
//     const newNumber = number => number * factor;
//     return newNumber;
// }
// console.log(createMultiplier(10) (2));  // перший арг піде в зовішню функцію, 2 арг піде у внутрішню функцію


// додаткові варіанти з поясненням :
// /**
//  * Ця функція є "фабрикою" для інших функцій.
//  * Вона приймає "factor" і повертає нову функцію, яка буде множити
//  * будь-яке число на цей "factor".
//  *
//  * @param {number} factor - число, на яке будемо множити.
//  * @returns {function(number): number} - повертає нову функцію.
//  */
// function createMultiplier(factor) {
//     // Внутрішня функція, яка має доступ до "factor" з зовнішньої області видимості.
//     const newNumber = number => number * factor;
    
//     // Ми повертаємо саму функцію, а не результат її виконання.
//     return newNumber;
// }

// // Крок 1: Викликаємо зовнішню функцію `createMultiplier` і передаємо їй аргумент 5.
// // Вона повертає нову функцію, яка "запам'ятала" (через замикання)
// // що її "factor" дорівнює 5. Ми зберігаємо цю нову функцію у змінній.
// const multiplyBy5 = createMultiplier(5);

// // Крок 2: Тепер змінна `multiplyBy5` містить нашу "нову" функцію.
// // Ми можемо викликати її з іншим аргументом, наприклад, 10.
// // Вона виконає `10 * 5`.
// const result1 = multiplyBy5(10); // 50
// console.log(result1); // Виведе: 50

// // Крок 3: Ми можемо створити й інші множники з тим же кодом!
// // Наприклад, множник на 3.
// const multiplyBy3 = createMultiplier(3);
// const result2 = multiplyBy3(20); // 60
// console.log(result2); // Виведе: 60

// // Або ж можна зробити все в одному рядку (хоча це менш читабельно):
// // Спочатку викликаємо `createMultiplier(10)`
// // Отримаємо функцію, і одразу ж викликаємо її з аргументом 2.
// console.log(createMultiplier(10)(2)); // Виведе: 20





// Завдання 9: Комбінація функцій
// Створіть дві функції: add(a, b) та subtract(a, b). Кожна з них повинна повертати відповідний результат. Потім створіть функцію calculate(a, b, operation), яка приймає два числа та функцію-операцію як третій параметр. Викличте її для додавання та віднімання.



// function add(a, b) {
//     return a + b;
// }

// function substract(a, b) {
//     return a - b;
// }

// /**
//  * Performs the appropriate mathematical operation (+ or -)
//  * depending on the value of the operator parameter by calling
//  * the helper functions add or substract.
//  * @param {number} a - The first operand.
//  * @param {number} b - The second operand.
//  * @param {string} operator - The mathematical symbol for the operation ('+' or '-').
//  * @returns {number|string} The result of the operation or an error message.
//  */

// function calculate(a, b, operator) {

//     if (operator === '+') {
//         return add(a, b);
//     } else if (operator === '-') {
//         return substract(a, b)
//     } else {
//         return `Unexpected operator`
//     }

// }
// console.log(calculate(10, 5, '-'));


// Завдання 10: Функція з динамічною кількістю аргументів
// Створіть функцію sumAll, яка приймає необмежену кількість числових аргументів за допомогою оператора rest (...args). Функція повинна повертати суму всіх переданих чисел.

// /**
//  * @function sumAll
//  * Sums the unlimited quantity of arguments passed to a function
//  * @param  {...number} args - collection of numbers to be added
//  * @returns {number} Total sum of all arguments
//  */


// const sumAll = function (...args) {
//     let sum = 0;
//     for (const num of args) {
//         sum += num;
//     }
//     return sum;
// }

// console.log(sumAll(2, 2, 2, 2));

// -------------------------------------------------------------------------------------------------------------------------------------

// /**
//  * Ваше завдання: Додати повний JSDoc-коментар для цієї функції.
//  * Опишіть, що вона робить, які параметри приймає та що повертає.
//  */

// /**
//  * Function calculates the amount of discount
//  * @param {number} price - the clear price of product.
//  * @param {number} discountPercentage - the discount percentage
//  * @returns {number|string} - discounted price or error message
//  */
// function calculateDiscountedPrice(price, discountPercentage) {
//   // Розраховує ціну з урахуванням знижки
//   if (discountPercentage < 0 || discountPercentage > 100) {
//     return 'Invalid discount percentage';
//   }
//   const discountAmount = (price * discountPercentage) / 100;
//   return price - discountAmount;
// }

// // ---

// /**
//  * Ваше завдання: Документувати цей метод.
//  * Вкажіть, що це метод класу, та опишіть, що він повертає.
//  */


// class User {
//   constructor(firstName, lastName) {
//     this.firstName = firstName;
//     this.lastName = lastName;
//   }

//   /**
//    * @method getFullName
//    * @returns {string} full user name composed of two properties
//    */
//   getFullName() {
//     // Повертає повне ім'я користувача (ім'я та прізвище)
//     return `${this.firstName} ${this.lastName}`;
//   }
// }

// // ---

// /**
//  * Ваше завдання: Додати JSDoc до асинхронної функції.
//  * Опишіть її призначення, що вона повертає (проміс), та які можуть виникнути помилки.
//  */

// /**
//  * Fetches user data from a remote source.
//  * @async
//  * @param {string} userId - The unique identifier of the user.
//  * @returns {Promise<object>} - A Promise that resolves with a user data object on success.
//  * @throws {Error} If the request fails or data is unavailable.
//  */
// async function fetchUserData(userId) {
//   const isAvailable = Math.random() > 0.5;
//   if (!isAvailable) {
//     throw new Error('User data is currently unavailable.');
//   }

//   // Імітує запит до API та повертає дані користувача
//   return {
//     id: userId,
//     name: 'Jane Doe',
//     email: 'jane.doe@example.com'
//   };
// }

// // ---

// /**
//  * Ваше завдання: Документувати цю функцію та її параметр-коллбек.
//  * Поясніть, що `callback` очікує два аргументи: `item` та `index`.
//  */

// /**
//  * This callback is invoked for each item in an array.
//  * @callback ItemProcessor
//  * @param {*} item - The current array item.
//  * @param {number} index - The index of the current item.
//  * @param {Array<*>} array - The original array.
//  */

// /**
//  * Iterates over an array and applies a callback function to each element.
//  * @param {Array<*>} arr - The array to be processed.
//  * @param {ItemProcessor} callback - The function to be called for each item.
//  */
// function processArrayWithCallback(arr, callback) {
//   // Проходить по масиву та для кожного елемента викликає коллбек-функцію
//   for (let i = 0; i < arr.length; i++) {
//     callback(arr[i], i);
//   }
// }


// --------------------------------------------------------------------------------------------------------------------------



// Завдання 1: Основи об'єктів
// Створіть об'єкт книга з властивостями назва, автор і рік. Призначте їм довільні значення.
// Виведіть увесь об'єкт у консоль.
// Змініть значення властивості рік на нове.
// Додайте нову властивість жанр до об'єкта.
// Видаліть властивість автор з об'єкта.
// Виведіть фінальний стан об'єкта книга у консоль.


// const book = {
//     name: 'Harry Potter',
//     author: 'J.K.Rowling',
//     year: 1991
// }

// console.log(book);

// book.year = 1992;
// book.genre = 'fantasy';

// delete book.author;
// console.log(book);


// ------------------------------------------------------------------------------------------------------------------------------------------

// Завдання 2: Поверхневе копіювання
// Створіть об'єкт телефон з властивостями бренд, модель і характеристики, де характеристики — це вкладений об'єкт з властивостями пам'ять і колір.
// Створіть поверхневу копію об'єкта телефон і назвіть її телефон_копія. Використайте для цього оператор розширення (...) або Object.assign().
// Змініть властивість модель у телефон_копія.
// Змініть властивість пам'ять у вкладеному об'єкті характеристики в телефон_копія.
// Виведіть обидва об'єкти (телефон та телефон_копія) у консоль і поясніть, чому зміни, внесені в характеристики копії, вплинули на оригінал.

// const phone = {
//     brand: 'Samsung',
//     model: 'Galaxy A24',
//     characteristics: {
//         memory: '128 GB',
//         color: 'olive'
//     }
// }

// const phoneCopy = Object.assign({}, phone);

// phoneCopy.model = 'Galaxy A25';

// phoneCopy.characteristics.memory = '132 GB';

// console.log(phone);
// console.log(phoneCopy);

// Зміни внесені в характеристики копї телефона вплинули і на оригінал, тому що за допомогою Object.assign ми зробили Shallow copy яка копіює обєкт не враховуючи вкладення, тобто перший шар властивостей. Вкладені властивості всеодно залишаються посиланнями на оригінальний обєкт. Для того щоб цього уникнути при потрібно робити глибоке копіювання обєкту (до якого ми дійдемо пізніше)

// ------------------------------------------------------------------------------------------------------------------------------------------------

// Завдання 3: Робота з масивами об'єктів
// Створіть масив користувачі, що містить щонайменше два об'єкти. Кожен об'єкт повинен мати властивості ім'я та id.
// Використайте метод масиву, щоб знайти об'єкт, де id дорівнює 2, і збережіть його в окрему змінну.
// Змініть властивість ім'я у знайденому об'єкті.
// Виведіть оригінальний масив користувачі у консоль і поясніть, чому зміна в окремому об'єкті вплинула на об'єкт у масиві.


// const users = [
//     {
//      userName: 'Anna',
//      userId: 1
//     }, 
//     {
//      userName: 'Tonya',
//      userId: 2
//     }
// ];

// // Використовуємо метод .find(), щоб знайти об'єкт, у якого id дорівнює 2.
// // Зберігаємо знайдений об'єкт у змінну userToUpdate.
// // Метод .find() проходить по масиву, і для кожного елемента (користувача)
// // перевіряє, чи user.id === 2. Як тільки він знаходить перший збіг,
// // він повертає об'єкт і зупиняється.
// const userToUpdate = users.find(user => user.userId === 2);
// console.log(userToUpdate);

// // Змінюємо властивість 'name' у знайденому об'єкті.
// // Важливо: ми змінюємо властивість самого об'єкта, на який посилається змінна.
// if (userToUpdate) {
//     userToUpdate.userName = 'Petro';
// }

// console.log(users); // Anna  Petro
// // Об'єкти в JavaScript передаються не за значенням, а за посиланням.
// // Це означає, що коли ми використали метод .find() і зберегли результат
// // у змінну userToUpdate, ми не створили новий об'єкт-копію.
// // Натомість, змінна userToUpdate містить посилання (адресу в пам'яті)
// // на той самий об'єкт, що знаходиться всередині масиву users.
// // Тому, коли ми змінили властивість .name через змінну userToUpdate,
// // ми фактично змінили оригінальний об'єкт, який знаходиться в масиві.

// -------------------------------------------------------------------------------------------------------------------------------------------

// Завдання 4: Робота з каталогом товарів
// Інструкція:
// Створіть масив products, який містить принаймні три об'єкти. Кожен об'єкт повинен мати властивості name, id та price.
// Використайте метод масиву, щоб знайти об'єкт, у якого id дорівнює 3, і збережіть його в окрему змінну.
// Змініть властивість price у знайденому об'єкті, встановивши нове значення (наприклад, збільште його на 10%).
// Виведіть в консоль обидва значення: початковий масив products та окрему змінну зі знайденим об'єктом.
// Напишіть коротке пояснення, що ілюструє, чому зміна price в окремій змінній вплинула на оригінальний масив.

// const products = [
//     {
//         name: 'Anna',
//         id: 1,
//         price: 50
//     },
//     {
//         name: 'Tonya',
//         id: 2,
//         price: 75
//     },
//     {
//         name: 'Olya',
//         id: 3,
//         price: 98
//     },
// ];

// const userToUpdate = products.find(user => user.id === 3);

// if (userToUpdate) {
//     userToUpdate.price = userToUpdate.price + (userToUpdate.price * 10 / 100);
// }

// console.log(products);

// -------------------------------------------------------------------------------------------------------------------------------------------

// Завдання: Керування інвентаризацією
// Уявіть, що ви ведете список товарів на складі. Ваше завдання — створити JavaScript-код для виконання таких операцій:
// Створіть масив об'єктів inventory, де кожен об'єкт представляє товар і містить такі властивості:
// id (унікальний ідентифікатор, число)
// name (назва товару, рядок)
// quantity (кількість на складі, число)
// price (ціна за одиницю, число)
// Наповніть масив трьома-чотирма товарами на свій розсуд.
// Напишіть функцію updateQuantity(itemId, newQuantity), яка приймає id товару та нову кількість. Функція повинна знайти товар за id і оновити його кількість на нове значення. Якщо товар не знайдено, виведіть повідомлення в консоль, наприклад, "Товар з таким ID не знайдено."
// Викличте функцію updateQuantity для одного з товарів, щоб перевірити, як вона працює.
// Виведіть оновлений масив inventory у консоль, щоб переконатися, що зміни відбулися.


// const inventory = [
//     {
//         id: 1,
//         name: 'tomato',
//         quantity: 15,
//         price: 30
//     },
//     {
//         id: 2,
//         name: 'cucumber',
//         quantity: 84,
//         price: 20
//     },
//     {
//         id: 3,
//         name: 'cabage',
//         quantity: 56,
//         price: 18
//     },
//     {
//         id: 4,
//         name: 'eggplant',
//         quantity: 28,
//         price: 45
//     }
// ]

// const updateQuantity = function (itemId, newQuantity) {
//     // Шукаємо товар за його ID
//     const inventoryItem = inventory.find(item => item.id === itemId);

//     // Перевіряємо, чи був знайдений товар
//     if (inventoryItem) {
//         // Якщо товар знайдено, оновлюємо його кількість
//         inventoryItem.quantity = newQuantity;
//         console.log(`Кількість товару "${inventoryItem.name}" оновлено до ${newQuantity}.`);
//     } else {
//         // Якщо товар не знайдено, виводимо повідомлення про помилку
//         console.log(`Помилка: Товар з ID ${itemId} не знайдено.`);
//     }
// };

// updateQuantity(4, 36);
// console.log(inventory);

// --------------------------------------------------------------------------------------------------------------------------------------------------


// Ми маємо масив об'єктів users, де кожен об'єкт представляє користувача з його ID, ім'ям та списком куплених товарів (purchases). Ваша мета — написати функцію calculateTotalSpent, яка буде:
// Приймати userId як аргумент.
// Знаходити відповідного користувача в масиві users.
// Використовуючи метод reduce(), розраховувати загальну суму, витрачену цим користувачем на всі його покупки.
// Повертати цю загальну суму.
// Якщо користувача з таким ID не знайдено, функція повинна повертати 0.

// const users = [
//     {
//         id: 1,
//         name: 'Олег',
//         purchases: [
//             { item: 'книга', price: 250 },
//             { item: 'ручка', price: 15 },
//             { item: 'зошит', price: 40 }
//         ]
//     },
//     {
//         id: 2,
//         name: 'Олена',
//         purchases: [
//             { item: 'пазл', price: 120 },
//             { item: 'іграшка', price: 220 }
//         ]
//     },
//     {
//         id: 3,
//         name: 'Іван',
//         purchases: [
//             { item: 'футболка', price: 300 }
//         ]
//     }
// ];



// const calculateTotalSpent = function (userId) {

//     // 1. Знайдіть користувача за його ID
//     // Використайте метод .find()
//     let currentUser = users.find(user => user.id === userId);

//     // 2. Якщо користувача не знайдено, поверніть 0
//     if (!currentUser) {
//         return 0;
//     }

//     // 3. Використайте метод .reduce() для розрахунку загальної суми
//     // Не забудьте про початкове значення для reduce(), яке тут дорівнює 0
//     const totalSum = currentUser.purchases.reduce((accum, purchase) => {
//         // На кожній ітерації додаємо ціну покупки до накопичувача
//         return accum + purchase.price;
//     }, 0); // Початкове значення акумулятора

//     return totalSum;
    
// }

// console.log(`Загальні витрати Олега: ${calculateTotalSpent(1)} грн.`); // Очікуваний результат: 305
// console.log(`Загальні витрати Олени: ${calculateTotalSpent(2)} грн.`); // Очікуваний результат: 340
// console.log(`Загальні витрати Івана: ${calculateTotalSpent(3)} грн.`); // Очікуваний результат: 300
// console.log(`Загальні витрати неіснуючого користувача: ${calculateTotalSpent(4)} грн.`); // Очікуваний результат: 0


// ---------------------------------------------------------------------------------------------------------------------------------------------


// У вас є об'єкт user, який представляє інформацію про користувача. Ваше завдання — написати функцію updateUser, яка:
// Прийматиме сам об'єкт user, ключ (наприклад, 'age') та нове значення для цього ключа.
// Оновлюватиме значення властивості в об'єкті за наданим ключем.
// Додаватиме нову властивість 'isVerified' зі значенням true.
// Повертатиме оновлений об'єкт.
// Спробуйте зробити це, не використовуючи методи масивів, а лише властивості об'єктів. Це допоможе вам краще зрозуміти, як працювати з об'єктами напряму.

// const user = {
//     name: 'Ірина',
//     age: 28,
//     city: 'Київ'
// };

// function updateUser (userObject, key, newValue) {
// // Щоб використовувати значення змінної як ім'я властивості, потрібно застосувати дужковий синтаксис (квадратні дужки []). 
// // Бо якщо я напишу userObject.key =  newValue; то до обєкту просто додасться нова властивість key з значенням 'Vinnitsya'
// // Тобто щоб key як змінну (парам функції) застосувати (а не як буквальну назву властивості треба квадратні дужки []
//     userObject[key] =  newValue;

//     userObject.isVerified = true;
//     return userObject;
// }

// updateUser(user, 'city', 'Vinnitsya');
// console.log(user);



// -----------------------------------------------------------------------------------------------------------------------------------------



// Задача: Видалення властивості
// Ця задача допоможе вам попрактикуватися у видаленні властивостей з об'єкта. Це базова операція, яка часто використовується на практиці.
// Ваше завдання — створити функцію removeProperty, яка:
// Приймає два параметри: userObject (об'єкт, з якого потрібно видалити властивість) і key (ім'я властивості, яку потрібно видалити).
// Видаляє властивість з userObject за допомогою ключа, що передається.
// Повертає оновлений об'єкт.

// const user = {
//     name: 'Ірина',
//     age: 28,
//     city: 'Київ'
// };

// function removeProperty (userObject, key) {
//     // додати перевірку, чи існує така властивість в об'єкті, перш ніж намагатися її видалити. Це робить функцію більш стійкою до помилок.
//     if (userObject.hasOwnProperty(key)) {
//         delete userObject[key];
//     }
//     return userObject;
// }

// // Коли ви звертаєтеся до ключа об'єкта, він має бути рядком (або Symbol), тому його потрібно взяти в лапки.
// console.log(removeProperty(user, 'age'));



// ----------------------------------------------------------------------------------------------------------------------------------------------------


// Напиши функцію JavaScript під назвою countWords, яка приймає один аргумент — рядок (string). Ця функція повинна повертати об'єкт, де ключами є слова з рядка, а значеннями — кількість їхніх повторень.
// Приклад:
// Якщо вхідний рядок такий: "Кіт і собака. Кіт — найкращий друг."
// Функція повинна повернути такий об'єкт:
// {
//   "кіт": 2,
//   "і": 1,
//   "собака": 1,
//   "найкращий": 1,
//   "друг": 1
// }
// Зверніть увагу на такі моменти:
// Слова повинні бути в нижньому регістрі.
// Розділові знаки (наприклад, крапка, кома, тире) не повинні бути частиною слів.

// function countWords (string) {

//     // Створюємо об'єкт для зберігання результатів.
//     const wordsObj = {}

//     // розділити стрінг на слова в масив
//     // Очищаємо рядок від розділових знаків, переводимо в нижній регістр
//     // і ділимо на окремі слова, використовуючи регулярний вираз.
//     // Регулярний вираз `/[a-zA-Zа-яА-Я0-9]+/g` шукає послідовності літер та цифр.
//     // Добре працює на англ.мові але не відпрацьовує правильно на укр.
//     const wordsArr = string.toLowerCase().match(/[a-zA-Zа-яА-Я0-9]+/g);
//     console.log(wordsArr);

//     //      // ще один варіант для англ. мови але не працює для укр мови
//     //     // Регулярний вираз `/\W+/g` розділяє рядок за будь-якими символами, що не є "словами".
//     //     const wordsArr = text.toLowerCase().split(/\W+/g).filter(Boolean);

//     // Якщо масив пустий (наприклад, рядок був порожній), повертаємо пустий об'єкт.
//     if (!wordsArr) {
//         return wordsObj;
//     }

//     // пройтись по масиву і пошукати однакові слова
//     // Крок 2: Підрахунок слів
//     // Проходимося по кожному слову в масиві.
//     for (const word of wordsArr) {
//         // Перевіряємо, чи вже існує це слово як ключ в нашому об'єкті.
//         // Це можна зробити за допомогою `wordsObj[word]`. Якщо ключа немає,
//         // його значення буде `undefined`, що в умовах `if` буде трактуватися як `false`.
//         if (wordsObj[word]) {
//             // Якщо слово вже є, збільшуємо його значення на 1.
//             wordsObj[word]++;
//         } else {
//             // Якщо слова ще немає, додаємо його в об'єкт
//             // і присвоюємо йому початкове значення 1.
//             wordsObj[word] = 1;
//         }
//     }

//     // Крок 3: Повернення результату
//     // Повертаємо готовий об'єкт.
//     return wordsObj;
// }


// const text2 = 'If I love you, you love me!';
// console.log(countWords(text2));

// // Тестуємо функцію з прикладом:
// const text = 'Кіт і собака. Кіт — найкращий друг.';
// console.log(countWords(text));

// // Тестуємо з іншим рядком, щоб переконатися, що все працює правильно:
// const anotherText = 'Мене тут немає, для тебе мене теж немає';
// console.log(countWords(anotherText));



// //  Складніший варіант рішення щоб правильно оброблялась і українська і англійська мовва

// /**
//  * Функція, що рахує повторення слів у рядку.
//  * Ця версія є більш надійною, оскільки не залежить від складних регулярних виразів.
//  * @param {string} text - Вхідний рядок, який потрібно обробити.
//  * @returns {Object} Об'єкт, де ключами є слова, а значеннями - кількість їхніх повторень.
//  */
// function countWords(text) {
//     // Крок 1: Підготовка
//     // Створюємо об'єкт для зберігання результатів.
//     const wordsObj = {};

//     // Очищаємо рядок від розділових знаків (замінюємо розділові знаки на пробіли які потім відріжем) та переводимо в нижній регістр.
//     // Регулярний вираз `/[.,—?!]/g` видаляє такі знаки пунктуації.
//     const cleanedText = text.toLowerCase().replace(/[.,—?!]/g, ' ');

//     // Розділяємо рядок на окремі слова, використовуючи пробіли як роздільник і для кожного слова видаляєм зайві пробіли на початку та кінці слова.
//     const wordsArr = cleanedText.split(' ').filter(word => word.trim() !== '');

//     // Якщо масив пустий, повертаємо пустий об'єкт.
//     if (!wordsArr || wordsArr.length === 0) {
//         return wordsObj;
//     }

//     // Крок 2: Підрахунок слів
//     // Проходимося по кожному слову в масиві.
//     for (const word of wordsArr) {
//         // Перевіряємо, чи слово вже існує як ключ в нашому об'єкті.
//         // Використовуємо .trim() на всякий випадок, щоб прибрати зайві пробіли.
//         const trimmedWord = word.trim();
//         if (trimmedWord.length > 0) {
//             if (wordsObj[trimmedWord]) {
//                 // Якщо слово вже є, збільшуємо його значення на 1.
//                 wordsObj[trimmedWord]++;
//             } else {
//                 // Якщо слова ще немає, додаємо його в об'єкт
//                 // і присвоюємо йому початкове значення 1.
//                 wordsObj[trimmedWord] = 1;
//             }
//         }
//     }

//     // Крок 3: Повернення результату
//     // Повертаємо готовий об'єкт.
//     return wordsObj;
// }

// // Тестуємо функцію з прикладом:
// const text = 'Кіт і собака. Кіт — найкращий друг.';
// console.log(countWords(text));
// // Очікуваний результат: { 'кіт': 2, 'і': 1, 'собака': 1, 'найкращий': 1, 'друг': 1 }

// // Тестуємо з іншим рядком:
// const anotherText = 'Мене тут немає, для тебе мене теж немає: я зв"язана!';
// console.log(countWords(anotherText));
// // Очікуваний результат: { 'мене': 2, 'тут': 1, 'немає': 2, 'для': 1, 'тебе': 1, 'теж': 1 }


// --------------------------------------------------------------------------------------------------------------------


// Задача 1: Створення об'єктів для бібліотеки
// Завдання: Напиши функцію-конструктор Book, яка буде створювати об'єкти з трьома властивостями:
// title (назва книги)
// author (автор)
// year (рік видання)
// Потім створи два екземпляри об'єкта Book з довільними даними.

// function Book (title, author, year) {
//     this.title = title;
//     this.author = author;
//     this.year = year;
// }

// const book1 = new Book ('Harry Potter', 'J.K.Rowling', 1991);
// const book2 = new Book ('Harry Potter2', 'J.K.Rowling', 1992);

// console.log(book1, book2);




// Задача 2: Додавання методів через prototype
// Завдання: Візьми функцію-конструктор Book із попередньої задачі. Додай до її прототипу (Book.prototype) метод getSummary, який буде повертати рядок у такому форматі: "Назва книги 'Назва' була написана автором 'Автор' у році 'Рік'.".
// Створи один екземпляр Book і виклич для нього цей метод.

// function Book (title, author, year) {
//     this.title = title;
//     this.author = author;
//     this.year = year;
// }

// Book.prototype.getSummary = function () {
//     return `Назва книги ${title} була написана автором ${author} у році ${year}.`
// }

// const book1 = new Book ('Harry Potter', 'J.K.Rowling', 1991);
// const book2 = new Book ('Harry Potter2', 'J.K.Rowling', 1992);

// console.log(book1.getSummary());
// console.log(book2.getSummary());

// console.log(book1, book2);


// Задача 3: Перевірка типу об'єкта
// Завдання: Створи функцію-конструктор Car з властивостями brand і model.
// Створи два об'єкти: один за допомогою new Car() та інший — звичайний об'єкт {}.
// За допомогою оператора instanceof перевір, чи обидва об'єкти є екземплярами Car, та виведи результат у консоль.


// function Car (brand, model) {
//     this.brand = brand;
//     this.model = model;
// }

// const car1 = new Car('Mazda', 'CX30');
// const car2 = {};
// const car3 = Car('BMW', 'X5');

// console.log(car1 instanceof Car);  // true
// console.log(car2 instanceof Car);  // false
// console.log(car3 instanceof Car);  // false

// console.log(car1);  // Car {brand: 'Mazda', model: 'CX30'}
// console.log(car2);  // {}
// console.log(car3);  // undefined




// Задача 1: Проста ієрархія
// Напиши функцію-конструктор Animal та іншу функцію-конструктор Dog. Зроби так, щоб Dog наслідував Animal. Потім створи об'єкт myDog за допомогою Dog і перевір, чи myDog є екземпляром обох Dog та Animal за допомогою instanceof. Поясни, чому обидві перевірки повертають true.

// function Animal () {
//     this.isMammal = true;
// }

// function Dog () {
//     // 1. Викликаємо конструктор батьківського класу (Animal)
//     // Це дозволяє скопіювати властивості Animal (наприклад, isMammal) в наш новий об'єкт Dog.
//     Animal.call(this);
//     this.name = 'Dog';

// }

// // 2. Встановлюємо ланцюжок прототипів
// // Ми робимо прототипом Dog новий об'єкт, який є екземпляром Animal.
// // Це і створює правильний зв'язок для instanceof.
// Dog.prototype = new Animal();

// // 3. Важливо! Відновлюємо властивість конструктора
// // Оскільки ми замінили прототип, нам потрібно вказати, хто є справжнім конструктором для Dog.
// Dog.prototype.constructor = Dog;


// const dog1 = new Dog();
// console.log(dog1 instanceof Dog);
// console.log(dog1 instanceof Animal);
// console.log(dog1.isMammal);
// Зверни увагу, конструктор Animal викликається двічі:
// один раз для створення прототипу (Dog.prototype = new Animal()),
// і один раз для створення самого об'єкта (Animal.call(this)).
// Це особливість старого прототипного наслідування.



// Задача 2: Розуміння динамічних змін
// Дано наступний код. Подумай, що виведеться в консоль.
// JavaScript
// function Employee(name) {
//   this.name = name;
// }
// const employee1 = new Employee('Іван');
// // Додаємо прототип 'Manager'
// function Manager() {}
// Manager.prototype = employee1;
// const manager1 = new Manager();
// console.log(manager1 instanceof Manager);
// console.log(manager1 instanceof Employee);
// Поясни, чому результат саме такий. Зверни увагу на те, як динамічно змінюється ланцюжок прототипів.


// обєкт manager1 є інстансом Manager
// прототип обєкта manager1 є тим самим обєктом що й  Manager.prototype який посислається на employee1 який є інстансом Employee який є його прототипом.
// manager1 → Manager.prototype → Employee.prototype(через employee1 який сам поо собі не є частиною ланцюжка, а лише мостом для зєднання прототипів Manager і Employee).

// та ж 2 задача лиш з наслідуванням (а не лише прототипом ланцюжків)
// function Employee(name) {
//   this.name = name;
// }
// const employee1 = new Employee('Іван');
// // Додаємо прототип 'Manager'
// function Manager(name) {
//         Employee.call(this, name);
// }
// Manager.prototype = new Employee();
// Manager.prototype.constructor =  Manager;
// const manager1 = new Manager('Марія');
// console.log(manager1 instanceof Manager);
// console.log(manager1 instanceof Employee);
// console.log(manager1.name);
// console.log(employee1.name);



// Задача 3: instanceof та символи
// Згенеруй код, який створить два об'єкти: obj1 та obj2. Додай до obj1 спеціальний символ Symbol.hasInstance, який змусить instanceof повертати true для obj2, навіть якщо вони не мають жодного зв'язку.
// Ця задача покаже, як можна контролювати поведінку instanceof за допомогою символів, що є більш просунутою темою.

// // Створюємо перший об'єкт, який буде "псевдо-конструктором"
// const obj1 = {
//   // Додаємо спеціальний символ Symbol.hasInstance
//   // Це метод, який викликається, коли об'єкт знаходиться справа від instanceof
//   [Symbol.hasInstance](instance) {
//     // Цей метод повертає true, якщо об'єкт, що перевіряється (instance),
//     // відповідає певним умовам. У нашому випадку, ми просто завжди повертаємо true
//     // для демонстрації.
//     console.log("Виконується метод Symbol.hasInstance для перевірки.");
//     return true; 
//   }
// };

// // Створюємо другий об'єкт, який буде перевірятися
// const obj2 = {};

// console.log("Перевіряємо чи 'obj2' є екземпляром 'obj1' за допомогою instanceof.");

// // Зазвичай, ця перевірка повернула б false,
// // оскільки obj2 не є екземпляром obj1
// const isInstance = obj2 instanceof obj1;

// console.log(`Результат перевірки: ${isInstance}`); 

// // Перевірка показує true, хоча об'єкти не мають зв'язку,
// // що демонструє роботу Symbol.hasInstance.

// ---
// // У цьому коді ви побачите, що коли `instanceof` виконує перевірку, він спочатку шукає наявність 
// // символу `Symbol.hasInstance` на об'єкті, що знаходиться праворуч. Якщо він його знаходить, то викликає метод,
// //  визначений цим символом. Це дозволяє нам повністю контролювати, що буде повертати `instanceof`.




// Задача 1: Створення об'єкта "Студент"
// Створіть функцію-конструктор з назвою Student. Ця функція повинна приймати два аргументи: name (ім'я студента) та grade (його клас або курс).
// Кожен об'єкт, створений за допомогою new Student(...), повинен мати дві властивості: name і grade.
// Після цього створіть два об'єкти-студенти, наприклад, "Іван" (5-й клас) та "Марія" (7-й клас), і виведіть їх властивості в консоль.


// function Student(name, grade) {
//     this.name = name;
//     this.grade = grade;
// }

// const student1 = new Student ('Іван', 5);
// const student2 = new Student ('Марія', 7);

// console.log(student1, student2);






// Задача 2: Додавання методів за допомогою прототипу
// На основі попередньої задачі, додайте новий метод до конструктора Student.
// Метод повинен називатися sayHello і виводити в консоль рядок у форматі: "Привіт, мене звати [ім'я студента] і я навчаюся у [клас студента] класі."
// Підказка: Пам'ятайте, що методи краще додавати до прототипу конструктора (Student.prototype), щоб вони не дублювалися для кожного об'єкта, що заощадить пам'ять.
// Створіть новий об'єкт Student та викличте його метод sayHello.

// function Student(name, grade) {
//     this.name = name;
//     this.grade = grade;
// }

// Student.prototype.sayHello = function() {
//     console.log(`Привіт, мене звати ${this.name} і я навчаюся у ${this.grade} класі.`);
// }

// const student1 = new Student('Іван', 5);
// const student2 = new Student('Марія', 7);

// console.log(student1, student2);

// student1.sayHello();


// ------------------------------------------------------------------------------------------------------------------------------------------

// Задача 1: Ініціалізація та доступ
// Створіть масив під назвою фрукти, який містить три рядки: "яблуко", "банан" та "апельсин".
// Виведіть у консоль другий елемент масиву (банан).
// Замініть перший елемент (яблуко) на "ківі".
// Виведіть у консоль весь масив, щоб переконатися у змінах.

// const fruits = ['apple', 'banana', 'orange'];
// console.log(fruits[1]);
// fruits[0] = 'kiwi';
// console.log(fruits);


// Задача 2: Довжина масиву та останній елемент
// Створіть масив числа з п'яти довільних цілих чисел.
// Виведіть у консоль загальну кількість елементів у масиві.
// Використовуючи властивість length, виведіть у консоль останній елемент масиву.

// const numbers = [1, 15, 108, 24, 66];
// console.log(numbers.length);
// console.log(numbers[numbers.length - 1]);



// Задача 3: Простий перебір за допомогою for
// Створіть масив кольори з трьома рядками: "червоний", "зелений", "синій".
// Використовуючи цикл for, переберіть масив і виведіть кожен елемент у консоль.

// const colors = ['red', 'green', 'blue'];

// // for (let color = 0; color <= colors.length - 1; color++) {
// //     console.log(colors[color]);
// // }

// for (const color of colors) {
//     console.log(color);
// }


// Задача 4: Перебір за допомогою for...of
// Створіть масив тварини з кількома назвами тварин.
// Використовуючи цикл for...of, переберіть масив і виведіть у консоль кожну назву тварини.

// const animals = ['dog', 'cat', 'mouse', 'parrot'];

// for (const animal of animals) {
//     console.log(animal);
// }


// Задача 5: Обчислення суми елементів
// Створіть масив ціни з довільними числами.
// Використовуючи цикл for, обчисліть суму всіх елементів масиву.
// Збережіть суму в змінну загальнаСума.
// Виведіть у консоль загальнаСума разом із пояснювальним текстом, наприклад: "Загальна сума цін: <сума>".

// const prices = [105, 215, 98, 32];
// let totalSum = 0;

// for (const price of prices) {

//     totalSum += price;

// }
// console.log(`Total sum of prices is ${totalSum}`);



// Завдання 6
// Напишіть код, який об'єднає два масиви в один і виведе його у консоль.
// Масив 1: ['apple', 'banana', 'orange']
// Масив 2: ['grape', 'kiwi']


// const fruits1 = ['apple', 'banana', 'orange'];
// const fruits2 = ['grape', 'kiwi'];

// const fruits = [...fruits1, ... fruits2];

// fruits1[0] = 'avocado';
// console.log(fruits1);
// console.log(fruits);



// Завдання 7
// Напишіть код, який перевірить, чи є число парним, чи непарним.
// Якщо число парне — виведіть у консоль повідомлення "Число парне.", якщо непарне — "Число непарне.".
// Число для перевірки: 42

// const number = 42;

// if (number % 2 === 0) {
//     console.log(`${number} is an even number`);
// } else {
//     console.log(`${number} is an odd number`);
// }


// Завдання 8
// Напишіть код, який знайде найдовше слово у масиві.
// Масив для перевірки: ['apple', 'banana', 'kiwi', 'pineapple', 'grape'];


// const fruits = ['apple', 'banana', 'kiwi', 'pineapple', 'grape'];
// let longestName = '';

// for (const fruit of fruits) {

//     if (fruit.length > longestName.length) {
//         longestName = fruit;
//     }
// }

// console.log(longestName);




// Завдання 9
// Створіть код, який перетворить кожну літеру кожного слова в масиві на велику.
// Масив для перетворення: ['hello', 'world', 'in', 'javascript']
// Очікуваний результат: ['HELLO', 'WORLD', 'IN', 'JAVASCRIPT']


// const words = ['hello', 'world', 'in', 'javascript'];
// const wordsUpperCase = [];

// for (const word of words) {
//     // тут я в підкладаю слова в новий масив за тим самим індексом за яким вони знаходились в старому масиві
//     // (отримуючи індекс поточного елемента під час ітерації по старому масиву)
//     wordsUpperCase[words.indexOf(word)] = word.toUpperCase(); 

// }

// console.log(wordsUpperCase);



// Завдання 10
// Створіть код, який видалить перший та останній елементи з масиву.
// Масив для обробки: ['apple', 'banana', 'kiwi', 'pineapple', 'grape']
// Очікуваний результат: ['banana', 'kiwi', 'pineapple']

// // варіант 1
// let fruits = ['apple', 'banana', 'kiwi', 'pineapple', 'grape'].slice(1, -1);
// console.log(fruits);


// // варіант 2
// const fruits = ['apple', 'banana', 'kiwi', 'pineapple', 'grape'];
// const newFruits = [];

// // Проходимося по масиву, починаючи з другого елемента (індекс 1)
// // і зупиняємося перед останнім елементом (fruits.length - 1)
// for (let i = 1; i < fruits.length - 1; i++) {
//     newFruits.push(fruits[i]);
// }

// console.log(newFruits);


// варіант 3
// const fruits = ['apple', 'banana', 'kiwi', 'pineapple', 'grape'];

// // Розраховуємо довжину нового масиву
// const newLength = fruits.length - 2;
// // Створюємо новий порожній масив
// const newFruits = new Array(newLength);

// // Проходимося по елементах від індексу 1 до передостаннього
// for (let i = 0; i < newLength; i++) {
//     // Присвоюємо елементи з оригінального масиву
//     // (починаючи з індексу 1) до нового масиву
//     newFruits[i] = fruits[i + 1];
// }

// console.log(newFruits);




// Завдання 11
// Створіть код, який додасть новий елемент banana на початок масиву та новий елемент grape в кінець масиву.
// Масив для обробки: ['apple', 'kiwi', 'pineapple']
// Очікуваний результат: ['banana', 'apple', 'kiwi', 'pineapple', 'grape']

// 1 варіант
// const fruits = ['apple', 'kiwi', 'pineapple'];
// fruits.unshift('banana');
// fruits.push('grape');

// console.log(fruits);

// 2 варіант
// const fruits = ['apple', 'kiwi', 'pineapple'];
// const fruits2 = ['banana', ...fruits, 'grape'];
// console.log(fruits2);


// 3 варіант
// const fruits = ['apple', 'kiwi', 'pineapple'];
// const fruitsAddition = ['banana', 'grape'];
// const fruits2 = [fruitsAddition[0], ...fruits, fruitsAddition[1]];
// console.log(fruits2);




// 1. Збільшення віку
// Створіть поверхневу копію масиву users. Потім за допомогою циклу for...of або методу forEach збільшіть значення age на 1 
// для кожного об'єкта в новій копії. Виведіть обидва масиви в консоль, щоб переконатися, що оригінальний масив залишився без змін.

// const users = [
//   { name: 'Alice', age: 25 },
//   { name: 'Bob', age: 30 },
//   { name: 'Charlie', age: 35 }
// ];

// const usersCopy = [...users];
// for (user of usersCopy) {
//     user.age = user.age + 1;
// }

// console.log(usersCopy);
// console.log(users);  // зміняться одидва масиви, тому що я зробила лише поверхневу копію, а зміни вносила нв шар глибше

// 2. Подвоєння чисел
// Створіть поверхневу копію масиву numbers. Переберіть елементи в новій копії та за допомогою методу map створіть новий масив,
//  в якому кожне число буде помножене на 2. Виведіть обидва масиви, щоб переконатися, що оригінал не змінився.


// const numbers = [1, 2, 3, 4, 5];
// const numbersCopy = [...numbers].map(num => num * 2);
// const numbersCopy2 = Array.from(numbers).map(num => num * 3);

// console.log(numbers);
// console.log(numbersCopy);
// console.log(numbersCopy2);




// 3. Фільтрування та копіювання
// Створіть поверхневу копію масиву products. Використовуючи метод filter, створіть новий масив expensiveProducts, 
// що містить лише продукти, ціна яких більша за 100. Переконайтеся, що оригінальний масив products не змінився.


// const products = [
//   { name: 'Laptop', price: 1200 },
//   { name: 'Mouse', price: 25 },
//   { name: 'Keyboard', price: 75 },
//   { name: 'Monitor', price: 300 }
// ];

// const expensiveProducts = Array.from(products).filter(item => item.price > 100);

// console.log(expensiveProducts);
// console.log(products);


// 4. Зміна статусу
// Створіть поверхневу копію масиву tasks. Переберіть елементи в новій копії та змініть значення completed на true для всіх завдань. 
// Переконайтеся, що оригінальний масив залишився без змін.

// const tasks = [
//   { id: 1, text: 'Вивчити JavaScript', completed: false },
//   { id: 2, text: 'Написати код', completed: false },
//   { id: 3, text: 'Перевірити завдання', completed: false }
// ];

// const completedTasks = tasks.map(task => {
//   // Перевіряємо, чи завдання вже виконане.
//   if (task.completed === true) {
//     // Якщо так, повертаємо його копію без змін.
//     return { ...task };

//     //якщо не  задати тут else, то якщо task.completed вже true, if-блок не виконається, 
//     // і функція повертає undefined. У результаті, completedTasks буде містити undefined для таких елементів.
//     // тому шо map() повинене виконати якусь операцію з кожним елементом, а функція повинна повертати щось інакше поверне undefined
//     // і цей undefined замінить ті елементи які мали completed: true в початковому масиві
//   } else {
//     // Якщо ні, створюємо нову копію і змінюємо властивість completed.
//     return { ...task, completed: true };
//   }
// });

// console.log(completedTasks);




// 5. Об'єднання та сортування
// Створіть поверхневу копію масиву a, об'єднавши його з масивом b. Потім відсортуйте новий об'єднаний масив в порядку зростання.
//  Виведіть обидва оригінальних масиви та новий об'єднаний масив. Переконайтеся, що a та b не були змінені.


// const a = [5, 2, 8];
// const b = [1, 9, 3, 10];
// const aB = [...a, ...b].sort(function (a, b) {
//     return a - b
// });


// console.log(aB);
// console.log(aB2);

// [5, 2, 8, 1, 9, 3, 10]
// 5 - 2  = 3
// [2, 5, 8, 1, 9, 3, 10]
// 5 - 8 = -3
// [2, 5, 8, 1, 9, 3, 10]
// 8 - 1 = 7
// 5 - 1 = 4
// 2 - 1 = 1
// [1, 2, 5, 8, 9, 3, 10].
// 9 - 3 = 6
// 8 - 3 = 5
// 5 - 3 = 2
// 2 - 3 = -1
// [1, 2, 3, 5, 8, 9, 10]
// 9 - 10 = -1
// [1, 2, 3, 5, 8, 9, 10]


// ['a', 'b', 'c'].slice(1, 2)


// ----------------------------------------------------------------------------------------------------------------------------


// Завдання 1: Фільтрація та перетворення
// Опис:
// Дано масив об'єктів users. Відфільтруйте масив, щоб отримати лише користувачів, чий вік більше або дорівнює 30. 
// Після цього, створіть новий масив, який містить лише імена цих користувачів у верхньому регістрі.
// Вхідні дані:
// const users = [
//   { name: 'Іван', age: 25 },
//   { name: 'Марія', age: 32 },
//   { name: 'Петро', age: 41 },
//   { name: 'Ольга', age: 28 },
//   { name: 'Віктор', age: 35 }
// ];
// Очікуваний результат:
// ['МАРІЯ', 'ПЕТРО', 'ВІКТОР']

// const users = [
//   { name: 'Іван', age: 25 },
//   { name: 'Марія', age: 32 },
//   { name: 'Петро', age: 41 },
//   { name: 'Ольга', age: 28 },
//   { name: 'Віктор', age: 35 }
// ];


// const seniorUsersNames = users
//     .filter(user => user.age >= 30)
//     .map(user => user.name.toUpperCase());

// console.log(seniorUsersNames);  // ['МАРІЯ', 'ПЕТРО', 'ВІКТОР']
// console.log(users);



// Завдання 2: Обчислення середнього значення
// Опис:
// Дано масив чисел scores. Використовуючи метод reduce, обчисліть середнє арифметичне значення всіх елементів масиву.
// Вхідні дані:
// const scores = [85, 90, 78, 92, 88];
// Очікуваний результат:
// 86.6

//  const scores = [85, 90, 78, 92, 88];

//  const averageScore = scores.reduce((accum, score) => (accum + score), 0) / scores.length;
//  console.log(averageScore);




// Завдання 3: Пошук унікальних значень
// Опис:
// Дано масив data з повторюваними значеннями. Створіть новий масив, що міститиме лише унікальні значення, використовуючи комбінацію методів масивів або інших структур даних.
// Вхідні дані:
// const data = [1, 2, 3, 4, 3, 2, 5, 6, 1, 7];
// Очікуваний результат:
// [1, 2, 3, 4, 5, 6, 7]

// const data = [1, 2, 3, 4, 3, 2, 5, 6, 1, 7];
// const dataSet = Array.from(new Set(data));
// console.log(dataSet);

// const data = [1, 2, 3, 4, 3, 2, 5, 6, 1, 7];
//     // Використовуємо метод filter() для створення нового масиву.
//     // Кожен елемент `num` та його індекс `index` перевіряються.
//     // Умова `data.indexOf(num) === index` є ключовою.
//     // Вона повертає `true` лише для першої появи елемента.
// let uniqueData = data.filter((num, index) => index === data.indexOf(num));
// console.log(uniqueData);




// Завдання 4: Групування за властивістю
// Опис:
// Дано масив products. Використовуючи reduce, згрупуйте продукти за категоріями, створюючи об'єкт, 
// де ключами є назви категорій, а значеннями — масиви продуктів, що до них належать.
// Вхідні дані:
// const products = [
//   { name: 'Яблуко', category: 'Фрукти' },
//   { name: 'Морква', category: 'Овочі' },
//   { name: 'Банан', category: 'Фрукти' },
//   { name: 'Картопля', category: 'Овочі' },
//   { name: 'Апельсин', category: 'Фрукти' }
// ];
// Очікуваний результат:
// {
//   "Фрукти": [
//     { "name": "Яблуко", "category": "Фрукти" },
//     { "name": "Банан", "category": "Фрукти" },
//     { "name": "Апельсин", "category": "Фрукти" }
//   ],
//   "Овочі": [
//     { "name": "Морква", "category": "Овочі" },
//     { "name": "Картопля", "category": "Овочі" }
//   ]
// }

// const products = [
//   { name: 'Яблуко', category: 'Фрукти' },
//   { name: 'Морква', category: 'Овочі' },
//   { name: 'Банан', category: 'Фрукти' },
//   { name: 'Картопля', category: 'Овочі' },
//   { name: 'Апельсин', category: 'Фрукти' }
// ];

// /**
//  * Групує елементи масиву за вказаною властивістю.
//  * @param {Array} array - Масив для групування.і
//  * @returns {Object} Об'єкт, згрупований за категоріями.
//  */
// const groupByCategory = (array) => {
//   // Використовуємо метод .reduce() для ітерації по масиву та створення нового об'єкта.
//   // .reduce() приймає два аргументи:
//   // 1. Коллбек-функція, яка викликається для кожного елемента масиву.
//   // 2. Початкове значення, яке стане першим значенням акумулятора. У нашому випадку це порожній об'єкт {}.
//   return array.reduce((accumulator, currentProduct) => {
//     // На кожній ітерації ми отримуємо два параметри:
//     // - accumulator: поточний результат (об'єкт, що ми будуємо).
//     // - currentProduct: поточний елемент масиву (один продукт).
    
//     // Отримуємо назву категорії поточного продукту.
//     const category = currentProduct.category;

//     // Перевіряємо, чи існує вже така категорія (ключ) в об'єкті-акумуляторі.
//     if (!accumulator[category]) {
//       // Якщо ні, створюємо новий ключ з назвою категорії та ініціалізуємо його порожнім масивом.
//       accumulator[category] = [];
//     }

//     // Додаємо поточний продукт до масиву відповідної категорії.
//     accumulator[category].push(currentProduct);

//     // Важливо: завжди повертаємо акумулятор з коллбек-функції.
//     // Це дозволяє передати змінений об'єкт на наступну ітерацію.
//     return accumulator;
//   }, {}); // {} - початкове значення для акумулятора.
// };

// const groupedProducts = groupByCategory(products);

// console.log(groupedProducts);


// Завдання 5: Перевірка на паліндром
// Опис:
// Напишіть функцію, яка приймає рядок і перевіряє, чи є він паліндромом (читається однаково в обох напрямках). 
// Використовуйте методи масивів, щоб розбити, обернути та з'єднати рядок. Ігноруйте регістр та пробіли.
// Вхідні дані:
// "А роза упала на лапу Азора"
// Очікуваний результат:
// true

// const palindrom = 'А роза упала на лапу Азора';


// рішення не дуже вдале хоча і працює, томущо багато повторень коду
// const isPalindrom = Array.from(palindrom.toLowerCase()).filter(char => char !== ' ').join('') === Array.from(palindrom.toLowerCase()).filter(char => char !== ' ').toReversed().join('');
// console.log(Array.from(palindrom.toLowerCase()).filter(char => char !== ' ').toReversed().join(''));
// console.log(Array.from(palindrom.toLowerCase()).filter(char => char !== ' ').join(''));
// console.log(isPalindrom);

// оптимальніше рішення (без дублювання коду і довгих рядків):

// const initialStr = 'А роза упала на лапу Азора';

// const isPalindrom = (str) => {
    
//     const cleanedStr = str.toLowerCase().replaceAll(' ', '');  // очистим рядок від пробілів і вирівняєм по нижньому регістру

//     const reversedCleanedStr = Array.from(cleanedStr).reverse().join('');  // очищений рядок перевернемо ззаду на перед

//     return cleanedStr === reversedCleanedStr;  // порівняємо обидва рядки
// }

// const isPalindromResult = isPalindrom(initialStr);  // збережемо результат порівняння щоб могти використати його далі (напр.вивести повідомлення)
// const message = isPalindromResult ? `Рядок "${initialStr}" є паліндромом: ${isPalindromResult}` : `Рядок "${initialStr}" не є паліндромом: ${isPalindromResult}`;
// console.log(message);


// ще одне рішення без використання методів масивів
// const initialStr = 'А роза упала на лапу Азора';
// const cleanedStr = initialStr.toLowerCase().replaceAll(' ', '');
// let reversedStr = '';

// for (char of cleanedStr) {
//     reversedStr = char + reversedStr;

// }

// const isPalindromResult = cleanedStr === reversedStr;
// const message = isPalindromResult ? `Рядок "${initialStr}" є паліндромом: ${isPalindromResult}` : `Рядок "${initialStr}" не є паліндромом: ${isPalindromResult}`;
// console.log(message);
// console.log(cleanedStr);
// console.log(reversedStr);


// Завдання 6: Видалення дублікатів з масиву об'єктів
// Опис:
// Дано масив items з об'єктами, що містять повторювані значення id. Створіть новий масив, який містить лише унікальні об'єкти, ґрунтуючись на їхньому id.
// Вхідні дані:
// const items = [
//   { id: 1, value: 'a' },
//   { id: 2, value: 'b' },
//   { id: 3, value: 'c' },
//   { id: 2, value: 'd' },
//   { id: 1, value: 'e' }
// ];
// Очікуваний результат:
// [
//   { id: 1, value: 'a' },
//   { id: 2, value: 'b' },
//   { id: 3, value: 'c' }
// ]

// const items = [
//   { id: 1, value: 'a' },
//   { id: 2, value: 'b' },
//   { id: 3, value: 'c' },
//   { id: 2, value: 'd' },
//   { id: 1, value: 'e' }
// ];


// 1 варіант через Set
// const seenIds = new Set();
// const uniqueItems = [];

// for (const item of items) {
//     // Первеіряєм чи є id поточного елемента вже в існуючих Set (Set спочатку пустий, і так ми його поступово наповнимо унікальними ID)
//     if (!seenIds.has(item.id)) {
//         // якщо нема в Set поточної ID то додаємо її в Set і зразу додаємо елемент в масив uniqueItems
//         // а якщо в Set вже є таке ID то воно просто ігнорується
//         seenIds.add(item.id);
//         uniqueItems.push(item);
//     }
// }

// console.log(uniqueItems);


// 2 варіант через .filter() та Map 

// Використовуємо Map для зберігання унікальних ID
// const seenIds = new Map();

// const uniqueItems = items.filter(item => {
//     // Використовуємо метод Map.has() для перевірки наявності ключа
//     if (!seenIds.has(item.id)) {
//         // Використовуємо метод Map.set() для додавання ключа
//         seenIds.set(item.id, true);
//         return true;
//     }
//     return false;
// });

// console.log('---');
// console.log('Фінальний масив унікальних елементів:', uniqueItems);
// console.log('Фінальний об’єкт seenIds (Map):', seenIds);

// 3 варіант через .reduce()

// const uniqueItems = items.reduce((accumulator, currentItem) => {
//     // Шукаємо чи існує обєкт з таким id в акумуляторі
//     const isDuplicate = accumulator.some(item => item.id === currentItem.id);

//     // якщо не існує такого id в accumulator то додаємо в нього елемент(обєкт)
//     // якщо існує то його ігноруємо
//     if (!isDuplicate) {
//         accumulator.push(currentItem);
//     }

//     // Повертаємо акумулятор - ми в ньому зробили відповідний масив унікальних обєктів
//     return accumulator;

// }, [])  // Початкове значення accumulator - пустий масив

// console.log(uniqueItems);


// 4 варіант через .filter() та обєкт

// створюємо порожній обєкт для зберігання унікальних ID  - тобто ми в обєкт додаватимемо властивість ID знначення якого true
// const seenIds = {};

// const uniqueItems = items.filter(item => {

//     // перевіряємо, чи є цей id в обєкті seenIds
//     // якщо item.id не існує як ключ в seenIds, значить його не існує
//     if (!seenIds[item.id]) {
//         // додаємо id до seenIds та зберігаємо обєкт
//         seenIds[item.id] = true;
//         console.log(Array.from(seenIds));
//         // додаємо елемент Item у новий масив uniqueItems (якщо перевірка для методу .filter повертає true то елемент зберігається в новий масив)
//         return true;
//     }

//     // якщо item.id вже існує як ключ в seenIds то ми його ігноруємо і повертаємо до нього false
//     // (якщо перевірка для методу .filter повертає false то елемент НЕ зберігається в новий масив)
//     return false;
// })
// console.log(Array.from(seenIds));
// console.log(uniqueItems);


// 5 варіант через масив
// const seenIdsArray = [];

// const uniqueItemsWithIncludes = items.filter(item => {
//     if (!seenIdsArray.includes(item.id)) {
//         seenIdsArray.push(item.id);
//         return true;
//     }
//     return false;
// });

// console.log(uniqueItemsWithIncludes);
// console.log(seenIdsArray);


// Завдання 7: Створення нового масиву без певного елемента
// Опис:
// Дано масив numbers та число 3. Створіть новий масив, який міститиме всі елементи, крім числа 3, не змінюючи оригінальний масив.
// Вхідні дані:
// const numbers = [1, 2, 3, 4, 5, 3];
// const numberToRemove = 3;
// Очікуваний результат:
// [1, 2, 4, 5]

// const numbers = [1, 2, 3, 4, 5, 3];
// const numberToRemove = 3;

// const changedNumbers = [...numbers].filter(num => num !== numberToRemove);
// console.log(changedNumbers);

// const changedNumbers2 = [];
// for (let num of numbers) {
//     if (num !== numberToRemove) {
//         changedNumbers2.push(num);
//     }
// }
// console.log(changedNumbers2);



// Завдання 8: Злиття масивів з унікальними значеннями
// Опис:
// Дано два масиви, arr1 та arr2. Об'єднайте їх в один масив, який міститиме лише унікальні значення.
// Вхідні дані:
// const arr1 = [1, 2, 3];
// const arr2 = [3, 4, 5];
// Очікуваний результат:
// [1, 2, 3, 4, 5]


// const arr1 = [1, 2, 3];
// const arr2 = [3, 4, 5];
// const unitedArr = Array.from(new Set([...arr1, ...arr2]));
// console.log(unitedArr);

// const arr1 = [1, 2, 3];
// const arr2 = [3, 4, 5];
// const unitedArr2 = arr1.concat(arr2).reduce((unique, item) =>{
//     return unique.includes(item) ? unique : [...unique, item];
// }, [])
// console.log(unitedArr2);

// const arr1 = [1, 2, 3];
// const arr2 = [3, 4, 5];
// const unitedArr3 = arr1.concat(arr2).reduce((unique, item) =>{
//      unique.includes(item) ? unique : unique.push(item);
//      return unique;
// }, [])
// console.log(unitedArr3);



// Завдання 9: Використання flatMap для вирівнювання та перетворення
// Опис:
// Дано масив масивів matrix. Використовуйте flatMap для створення одного масиву, який містить усі числа, помножені на 2.
// Вхідні дані:
// const matrix = [
//   [1, 2],
//   [3, 4],
//   [5, 6]
// ];
// Очікуваний результат:
// [2, 4, 6, 8, 10, 12]


// const matrix = [
//   [1, 2],
//   [3, 4],
//   [5, 6]
// ];


// // Використовуємо flatMap. 
// // Для кожного підмасиву (subArray), ми створюємо новий масив,
// // де кожен елемент помножений на 2.
// // flatMap автоматично "вирівняє" ці масиви в один.
// const result = matrix.flatMap(subArray => 
//   subArray.map(number => number * 2)
// );

// // Виводимо результат у консоль для перевірки
// console.log(result);


// Очікуваний результат: [2, 4, 6, 8, 10, 12]


// Завдання 9.1: Використання flatMap для вирівнювання та перетворення
// Опис:
// Дано масив масивів matrix. Використовуйте flatMap для створення одного масиву, який містить усі числа, помножені на 2.
// Вхідні дані:
// const matrix = [
//   [10, [1, 2]],
//   [20, [3, 4]],
//   [30, [5, 6]]
// ];
// Очікуваний результат: [10, 2, 4, 20, 6, 8, 30, 10, 12]

// /**
//  * Transforms a complex nested array by applying a function
//  * to its inner numerical elements and flattening the result.
//  */
// function transformMatrix(matrix) {
//   // We use flatMap тому що ми хочемо отримати єдиний, "плоский" масив
//   // на виході, згладивши всі підмасиви, які повертає наша функція-колбек.
//   return matrix.flatMap(item => {
//     // Кожен елемент "item" є масивом, наприклад, [10, [1, 2]]
//     const number = item[0]; // Перший елемент - це число
//     const subArray = item[1]; // Другий елемент - це підмасив

//     // Ми використовуємо метод map для того, щоб перетворити кожен елемент
//     // в subArray, помноживши його на 2.
//     const transformedSubArray = subArray.map(num => num * 2);

//     // Функція-колбек flatMap має повернути масив, який потім буде "згладжено".
//     // Тому ми створюємо новий масив, який містить оригінальне число
//     // та елементи з нашого перетвореного підмасиву.
//     // Оператор "..." (spread) розпаковує елементи transformedSubArray
//     // і додає їх в новий масив.
//     return [number, ...transformedSubArray];
//   });
// }

// const matrix = [
//   [10, [1, 2]],
//   [20, [3, 4]],
//   [30, [5, 6]]
// ];

// const result = transformMatrix(matrix);
// console.log(result);
// // Очікуваний результат: [10, 2, 4, 20, 6, 8, 30, 10, 12]





// Завдання 10: Пошук найдовшого слова
// Опис:
// Дано рядок sentence. Знайдіть найдовше слово в цьому реченні. Ігноруйте розділові знаки.
// Вхідні дані:
// const sentence = "Це є дуже цікаве та складне завдання!";
// Очікуваний результат:
// "завдання"


// const sentence = "Це є дуже цікаве та складне завдання!";

// const word = sentence
//   // Замінюємо всі розділові знаки (наприклад, крапку, кому, знак оклику)
//   // на порожній рядок. Регулярний вираз /[.,!?]/g означає:
//   // - [...] - будь-який символ всередині дужок.
//   // - g - прапорець, що означає "глобальний пошук", тобто замінити всі збіги, а не лише перший.
//             .replace(/[.,!?]/g, '')
//             .split(' ')
//             .reduce((accum, word) => {

//     if (word.length > accum.length) {
//         accum = word;

//     }
//     return accum;
// }, '');
// console.log(word);


// ----------------------------------------------------------------------------------------------------------------------

// Завдання 1: Привітання з колбеком
// Створи функцію sayHello, яка приймає два аргументи:
// Ім'я (рядок).
// Колбек-функцію callback.
// Всередині sayHello потрібно викликати колбек-функцію, передавши їй рядок-привітання, який ти створиш.
// Ось як це має працювати:
// Ти створюєш окрему функцію logMessage для виведення повідомлення в консоль.
// Ти викликаєш sayHello, передаючи туди своє ім'я та функцію logMessage як колбек.
// Приклад використання:
// sayHello("Оксана", logMessage); // У консолі має з'явитися "Привіт, Оксана!"

// function sayHello(name, cb) {
//     return cb(name);
// }

// function logMessage(name) {
//     console.log(`Привіт, ${name}!`);
// }


// sayHello('Анна', logMessage);




// Завдання 2: Обробка чисел з колбеком
// Створи функцію processNumbers, яка приймає два аргументи:
// Масив чисел numbers.
// Колбек-функцію callback.
// Всередині processNumbers ти маєш перебрати масив numbers і для кожного елемента викликати колбек-функцію, передаючи їй цей елемент.
// Приклад використання:
// Створи масив чисел, наприклад [1, 2, 3].
// Створи колбек-функцію doubleNumber, яка подвоює число і виводить результат у консоль.
// Виклич processNumbers, передавши туди масив і функцію doubleNumber.

// const numArr = [1, 2, 3];

// function processNumbers(arr, cb) {
//     arr.forEach(elem => {
//         cb(elem);
//     })
// }

// function doubleNumber(elem) {
//     console.log(elem * 2);
// }

// processNumbers(numArr, doubleNumber);




// Завдання 3: Фільтрація даних з колбеком
// Створи функцію filterArray, яка приймає два аргументи:
// Масив array.
// Колбек-функцію callback (це функція-умова, яка повертає true або false).
// Функція filterArray повинна повернути новий масив, що містить тільки ті елементи, для яких колбек-функція повернула true.
// Приклад використання:
// Створи масив рядків, наприклад, ["apple", "banana", "kiwi", "grape"].
// Створи колбек-функцію isLongEnough, яка перевіряє, чи довжина рядка більша за 4 символи.
// Виклич filterArray, передавши туди масив і функцію isLongEnough.


// const fruits = ["apple", "banana", "kiwi", "grape"];

// function isLongEnough(item) {

//     if (item.length <= 4) {
//         return false;
//     }
//     return true;
// }

// function filterArray(arr, cb) {
    
//     return arr.filter(item => {
//         return cb(item);
//     })
// }

// const filteredArr = filterArray(fruits, isLongEnough);
// console.log(filteredArr);




// Завдання 4: Трансформація даних з колбеком
// Створи функцію transformArray, яка приймає два аргументи:
// Масив чисел array.
// Колбек-функцію callback.
// Функція transformArray повинна повернути новий масив, кожен елемент якого є результатом виклику колбек-функції з відповідним елементом оригінального масиву.
// Приклад використання:
// Створи масив чисел, наприклад, [1, 2, 3, 4].
// Створи колбек-функцію addTen, яка додає 10 до числа.
// Виклич transformArray, передавши туди масив і функцію addTen.

// const numbers = [1, 2, 3, 4];

// function transformArray(arr, cb) {
//     return arr.map(num => cb(num));
// }

// function addTen(num) {

//     return num + 10;
// }

// const transformedArray = transformArray(numbers, addTen);
// console.log(transformedArray);



// Завдання 5: Обробка помилок із колбеками
// Створи функцію calculateAndHandle, яка приймає три аргументи:
// Два числа: num1 і num2.
// Колбек-функцію onSuccess, яка буде викликана, якщо обчислення успішне.
// Колбек-функцію onError, яка буде викликана, якщо сталася помилка.
// Функція calculateAndHandle повинна виконувати ділення num1 / num2.
// Якщо num2 дорівнює 0, це помилка. Виклич onError і передай їй повідомлення про помилку.
// В іншому випадку, якщо ділення успішне, виклич onSuccess і передай їй результат обчислення.
// Приклади використання:
// Виклич calculateAndHandle(10, 2, ...) з колбеками, які виводять результат.
// Виклич calculateAndHandle(10, 0, ...) з колбеками, які виводять помилку.



// function calculateAndHandle(num1, num2, cb) {
//     if (num2 === 0) {
//         onError(`Помилка, ділити на 0 не можливо!`);
//     } else {
//         const result = num1 / num2;
//         onSuccess(result);
//     }


// }
// function onSuccess(result) {
//     console.log(result);
// }

// function onError(result) {
//     console.log(result);
// }

// calculateAndHandle(10, 2, onSuccess);
// calculateAndHandle(10, 2, onError);
// calculateAndHandle(10, 0, onError);
// calculateAndHandle(10, 0, onSuccess);



// --------------------------------------------------------------------------------------------------------------------

// Для кожної задачі тобі потрібно буде написати дві окремі функції:
// Перша функція має використовувати об'єкт arguments.
// Друга функція має використовувати рест-параметр (...rest).
// Ось завдання:

// Завдання 1: Сума чисел
// Створи функцію sum, яка приймає необмежену кількість чисел і повертає їхню суму.
// sum(1, 2, 3) повинна повернути 6.
// sum(5, 10, 15, 20) повинна повернути 50.


// function sum () {
//     let total = 0;

//     for (let i = 0; i < arguments.length; i++) {
//         total += arguments[i];
//     }
//     return total;
// }
// console.log(sum(1, 2, 3));
// console.log(sum(5, 10, 15, 20));


// function sum2(...rest) {

//          return rest.reduce((accum, curr) => accum + curr);

// }
// console.log(sum2(1, 2, 3));
// console.log(sum2(5, 10, 15, 20));


// Завдання 2: Об'єднання рядків
// Створи функцію concatStrings, яка приймає необмежену кількість рядків і об'єднує їх в один, розділяючи кожен рядок пробілом.
// concatStrings('Hello', 'world', 'from', 'JS') повинна повернути 'Hello world from JS'.
// concatStrings('Today', 'is', 'a', 'great', 'day') повинна повернути 'Today is a great day'.


// function concatStrings() {

//     let concatedStrings = '';
//     for (let word of arguments) {

//         concatedStrings+= word + ' ';


//     }
//     return concatedStrings.trim();
// }

// console.log(concatStrings('Hello', 'world', 'from', 'JS'));
// console.log(concatStrings('Today', 'is', 'a', 'great', 'day'));


// function concatStrings2(...rest) {
//     return rest.join(' ');

// }

// console.log(concatedStrings('Hello', 'world', 'from', 'JS'));
// console.log(concatedStrings('Today', 'is', 'a', 'great', 'day'));


// const concatedStrings = (...rest) => rest.join(' ');

// console.log(concatedStrings('Hello', 'world', 'from', 'JS'));
// console.log(concatedStrings('Today', 'is', 'a', 'great', 'day'));



// Завдання 3: Фільтрування непарних чисел
// Створи функцію filterOdd, яка приймає необмежену кількість чисел. Перший аргумент — це початкове число, а всі наступні — це числа, з яких потрібно відфільтрувати непарні. Функція має повертати масив непарних чисел.
// filterOdd(10, 1, 2, 3, 4, 5) повинна повернути [1, 3, 5].
// filterOdd(0, 10, 11, 12, 13) повинна повернути [11, 13].

// function filterOdd() {
//     let oddNums = [];
//     for (num of arguments) {
//         if (num % 2 === 1) {
//             oddNums.push(num);
//         }
//     }
//     return oddNums;
// }

// console.log(filterOdd(10, 1, 2, 3, 4, 5));
// console.log(filterOdd(0, 10, 11, 12, 13));

// function filterOdd2(...numbers) {
//     return numbers.filter(number => number % 2 === 1);
// }

// console.log(filterOdd2(10, 1, 2, 3, 4, 5));
// console.log(filterOdd2(0, 10, 11, 12, 13));


// const filterOdd3 = (...numbers) => numbers.filter(number => number % 2 === 1)
// console.log(filterOdd3(10, 1, 2, 3, 4, 5));
// console.log(filterOdd3(0, 10, 11, 12, 13));

// Завдання 4: Знайти найдовший рядок
// Створи функцію findLongestString, яка приймає необмежену кількість рядків і повертає найдовший з них.
// findLongestString('a', 'apple', 'banana', 'cat') повинна повернути 'banana'.
// findLongestString('short', 'this is a long string', 'medium') повинна повернути 'this is a long string'.


// function findLongestString() {
//     let longestWord = '';
//     for (word of arguments) {
//         if (word.length > longestWord.length) {
//             longestWord = word;
//         }
//     }
//     return longestWord;
// }

// console.log(findLongestString('a', 'apple', 'banana', 'cat'));
// console.log(findLongestString('short', 'this is a long string', 'medium'));


// function findLongestString(...strings) {
//     return strings.reduce((accum ,currentStr) => {
//         if (currentStr.length > accum.length) {
//             accum = currentStr;
//             return accum;
//         } else {
//             return accum;
//         }
//  },'')
 
// }

// console.log(findLongestString('a', 'apple', 'banana', 'cat'));
// console.log(findLongestString('short', 'this is a long string', 'medium'));


// -------------------------------------------------------------------------------------------------------------------------------------------


// Завдання 1: Аналіз довжини та регістру
// Опис: Вам дано рядок: "Привіт, Світ! Це - Python!"
// Завдання:
// Знайдіть і виведіть на екран довжину цього рядка.
// Створіть його копію, де всі літери будуть великими.
// Створіть його копію, де всі літери будуть малими.
// Виведіть кожну з цих копій на екран.

// const str = 'Привіт, Світ! Це - Python!';
// console.log(str.length);
// const strCopy = str.slice(0).toUpperCase();
// console.log(strCopy);
// const strCopy1 = str.slice(0).toLowerCase();
// console.log(strCopy1);




// Завдання 2: Пошук та заміна
// Опис: Вам дано рядок: "Програмування - це весело і захоплююче!"
// Завдання:
// Перевірте, чи міститься в цьому рядку слово "весело".
// Замініть слово "весело" на "круто".
// Виведіть на екран початковий результат перевірки (true або false) та новий рядок після заміни.

// const str = 'Програмування - це весело і захоплююче!';
// console.log(str.includes('весело'));
// const str1 = str.replace('весело', 'круто');
// console.log(str1);



// Завдання 3: Розбиття та з'єднання рядків
// Опис: Вам дано рядок: "HTML, CSS, JavaScript, Python, C++"
// Завдання:
// Розділіть цей рядок на окремі елементи (мови програмування) за допомогою коми та пробілу.
// З'єднайте отримані елементи в новий рядок, використовуючи як роздільник знак | (вертикальна риска).
// Виведіть на екран обидва результати: масив після розбиття і новий рядок після з'єднання.

// const str = 'HTML, CSS, JavaScript, Python, C++';

// const arr = str.split(', ')
// const newStr = arr.join('|');
// console.log(arr);
// console.log(newStr);




// Завдання 4: Перетворення та форматування
// Опис: Вам дано число у вигляді рядка: "12345"
// Завдання:
// Перетворіть цей рядок на число.
// Застосуйте до числа математичну операцію (наприклад, додайте 100).
// Перетворіть отриманий результат назад у рядок.
// Виведіть на екран тип даних початкового рядка, тип даних числа, тип даних кінцевого рядка, а також сам кінцевий рядок.


// const str = '12345';
// const num = +str + 100;
// const str1 = num.toString();
// console.log(typeof str);
// console.log(typeof num);
// console.log(typeof str1);
// console.log(str1);




// Завдання 5: Пошук та індекси
// Опис: Вам дано рядок: "JavaScript — це мова програмування, яка робить вебсайт динамічним."
// Завдання:
// Знайдіть індекс першого входження слова "мова".
// Знайдіть індекс останнього входження слова "динамічним".
// Знайдіть індекс слова "Hello".
// Виведіть на екран усі три індекси.


// const str = 'JavaScript — це мова програмування, яка робить вебсайт динамічним.';
// console.log(str.indexOf('мова'));
// console.log(str.lastIndexOf('динамічним'));
// console.log(str.indexOf('Hello'));



// Завдання 6: Підрахунок символів
// Опис: У вас є рядок, що містить речення. 
// Ваше завдання — підрахувати кількість літер 'a' (як великих, так і малих) у цьому реченні.
// Рядок: "Яблуко — це дуже корисний фрукт, адже там багато вітамінів."
// Завдання: Напишіть код, який знайде кількість літер 'а' та виведе результат на консоль. 
// Підказка: скористайтеся методом toLowerCase() та split().


// const phrase = 'Яблуко — це дуже корисний фрукт, адже там багато вітамінів.';
// const phraseToLowerCase = phrase.toLowerCase();
// let charQuantity = 0;
// for (char of phraseToLowerCase) {

//     if (char === 'а') {
//         charQuantity += 1;
//     }
    
// }
// console.log(charQuantity);


// const phrase = 'Яблуко — це дуже корисний фрукт, адже там багато вітамінів.';
// const phraseToLowerCase = phrase.toLowerCase();
// const findA = /а/g;
// const foundA = phraseToLowerCase.match(findA);
// console.log(phraseToLowerCase);
// console.log(foundA.length);


// Це ще один спосіб, який іноді використовують для таких завдань.
//  Його суть полягає в тому, щоб розбити рядок на масив, використовуючи цільовий символ як роздільник. 
// Кількість елементів у масиві буде на один більшою, ніж кількість роздільників. 
// Тому, щоб отримати кількість символів, потрібно відняти одиницю від довжини масиву.

// const phrase = 'Яблуко — це дуже корисний фрукт, адже там багато вітамінів.';
// const phraseToLowerCase = phrase.toLowerCase();
// const countA = phraseToLowerCase.split('а').length - 1;
// console.log(phraseToLowerCase.split('а'));
// console.log(countA);




// Завдання 7: Перевірка на паліндром
// Опис: Паліндром — це слово або речення, яке читається однаково в обох напрямках. 
// Наприклад, "корок" або "А роза упала на лапу Азора".
// Ваше завдання — написати код, який перевірятиме, чи є даний рядок паліндромом.
// Рядок: "А роза упала на лапу Азора"
// Завдання: Напишіть код, який видалить усі пробіли та переведе рядок у нижній регістр, а потім перевірить, чи є він паліндромом. Виведіть результат (true або false) на консоль.

// const phrase = 'А роза упала на лапу Азора';
// const changedFrase = phrase.toLocaleLowerCase().replaceAll(' ', '');
// const standartizedFrase = Array.from(changedFrase).reverse().join('')


// if (changedFrase === standartizedFrase) {
//     console.log(`This phrase is a palindrom`);
// } else {
//     console.log('This phrase is not a palindrom');
// }

// console.log(standartizedFrase);
// console.log(changedFrase);



// const isPalindrome = (str) => {
//   // Переводимо рядок у нижній регістр та видаляємо пробіли за допомогою регулярних виразів
//   const cleanStr = str.toLowerCase().replace(/\s/g, '');

//   // Створюємо перевернутий рядок, розбиваємо посимвольно, перевертаємо та об'єднуємо
//   const reversedStr = cleanStr.split('').reverse().join('');

//   // Порівнюємо початковий та перевернутий рядки
//   return cleanStr === reversedStr;
// };

// // Приклади використання
// const phrase1 = 'А роза упала на лапу Азора';
// const phrase2 = 'Привіт, світ';

// console.log(`"${phrase1}" є паліндромом: ${isPalindrome(phrase1)}`);
// console.log(`"${phrase2}" є паліндромом: ${isPalindrome(phrase2)}`);



// const phrase = 'А роза упала на лапу Азора';

// function isPalindrom (string) {
//     const changedFrase = string.toLocaleLowerCase().replaceAll(' ', '');
//     let palindromPhrase = '';

//     for (char of changedFrase) {
//         palindromPhrase = char + palindromPhrase;
//     }

//     if (changedFrase === palindromPhrase) {
//         return `This phrase is a palindrom`
//     } else {
//         return `This phrase is not a palindrom`
//     }
// }

// console.log(isPalindrom(phrase));





// Завдання 8: Скорочення рядка
// Опис: Вам потрібно скоротити довгий рядок до певної довжини, додавши в кінці три крапки (...).
// Рядок: "Сьогодні чудовий день для вивчення JavaScript"
// Довжина: 20
// Завдання: Напишіть код, який перевірить довжину рядка. 
// Якщо вона більша за 20 символів, скоротіть його до 20 символів і додайте ... в кінці. 
// Виведіть результат на консоль.

// const phrase = 'Сьогодні чудовий день для вивчення JavaScript';

// const shortenPhrase = (str) => {
//     if (str && str.length > 20) {
//         return str.substr(0, 20).concat('...');
//     } else {
//         return str;
//     }
// }

// console.log(shortenPhrase(phrase));


// Завдання 9: Заміна слів у реченні
// Опис: Вам потрібно замінити всі входження одного слова в реченні на інше.
// Рядок: "Я вивчаю JavaScript, тому що JavaScript — це круто!"
// Завдання: Замініть усі входження слова "JavaScript" на "Node.js" і виведіть оновлений рядок на консоль. Підказка: використайте метод replace() із регулярним виразом та прапорцем g.


// const phrase = 'Я вивчаю JavaScript, тому що JavaScript — це круто!';
// const wordToReplace = 'Node.js'
// const wordToBeReplaced = 'JavaScript'

// const changePhrase = (str, word1, word2) => str.replaceAll(word1, word2);

// console.log(changePhrase(phrase, wordToBeReplaced, wordToReplace));




// Завдання 10: Форматування імені
// Опис: У вас є рядок з ім'ям, але він містить зайві пробіли та написаний не в тому регістрі.
// Рядок: "  іван пЕТРовИЧ   "
// Завдання:
// Видаліть зайві пробіли на початку та в кінці рядка.
// Зробіть першу літеру кожного слова великою, а решту — маленькими.
// Виведіть відформатоване ім'я на консоль.

// const name = '  іван пЕТРовИЧ   ';

// const formattedName = (str) => {
//     const trimmedAndLower = str.trim().toLowerCase();

//     const words = trimmedAndLower.split(' ');
//   // Проходимо по кожному слову, робимо першу літеру великою і додаємо решту слова,  повертаємо оновлений масив
//     const formattedWords = words.map(word => {
//         if (word.length > 0) {
//             return word.charAt(0).toUpperCase() + word.slice(1);
//         }
//         return '';
//     })

//     return formattedWords.join(' ');
// }

// console.log(formattedName(name));




// Завдання 11: Аналіз рядка
// Напишіть функцію, яка приймає рядок і повертає об'єкт з наступною інформацією:
// Кількість слів у рядку.
// Кількість символів у рядку (без пробілів).
// Найдовше слово в рядку.
// Масив унікальних слів у рядку (без повторень).
// Ось початкові дані:
// const text = '  Я вивчаю JavaScript, тому що JavaScript - це круто!  ';

// const text = '  Я вивчаю JavaScript, тому що JavaScript - це круто!  ';

// const analizeText = (str) => {
//     const strNoPunctuation = str
//         .trim()
//         .replaceAll(/[.,!?;:"'-]/g, '')
//         .replace(/\s+/g, ' ');

//     const wordsAmount = strNoPunctuation.split(' ');

//     const symbolAmount = strNoPunctuation.replace(/\s/g, '');

//     const longestWord = wordsAmount.reduce((longest, current) => {
//         return current.length > longest.length ? current : longest;
//     }, '');

//     const uniqueWords = Array.from(new Set(wordsAmount));

//     return {
//         words: wordsAmount.length,
//         symbols: symbolAmount.length,
//         longestWord: longestWord,
//         uniqueWords: uniqueWords
//     }

// }

// console.log(analizeText(text));





// Завдання 12: Керування списком покупок
// Напишіть одну функцію manageShoppingList, яка приймає три аргументи:
// list: початковий масив рядків (список покупок).
// action: рядок, який вказує, що робити. Можливі значення: 'add', 'remove', 'check'.
// item: рядок, який представляє товар.
// Функція повинна:
// Якщо action дорівнює 'add', додати item до кінця списку.
// Якщо action дорівнює 'remove', видалити перше входження item зі списку. Якщо товар не знайдено, нічого не робити.
// Якщо action дорівнює 'check', перевірити, чи є item у списку. Повернути true або false.
// УВАГА! Функція повинна бути pure function, тобто вона не повинна змінювати початковий масив list. Завжди повертайте новий масив.
// Покажіть, як ви можете використати цю функцію для трьох різних дій.


// const productsList = ['apple', 'kiwi', 'orange', 'banana', 'pineapple'];

// /**
//  * Керує списком покупок, виконуючи додавання, видалення або перевірку наявності товару.
//  * Функція є чистою і не змінює початковий список.
//  * @param {string[]} list - Початковий список покупок.
//  * @param {string} action - Дія ('add', 'remove', 'check').
//  * @param {string} item - Товар для додавання/видалення/перевірки.
//  * @returns {string[] | boolean} Оновлений список або булеве значення.
//  */

// const manageShoppingList = function (list, action, item) {

//     switch (action) {
//         case 'add':
//             // Додаємо елемент і повертаємо новий масив
//             return addProduct(list, item);
//             // break;  // в цьому випадку break непотрібні в жодному case тому що кожен з case містить return, який і зупинить виконання і switch і всієї функції
//         case 'remove':
//             return removeProduct(list, item);
//             // break;
//         case 'check':
//             return checkProduct(list, item);
//             // break;
//         default:
//             console.error("Помилка: Невідома дія!");
//             return [...list];
//     }

// }

// function addProduct (list, item) {
//      return [...list, item];
// }

// function removeProduct (list, item) {
//     // Знаходимо індекс першого входження товару
//       const index = list.indexOf(item);
//       // Якщо товар знайдено (індекс не -1)
//       if (index !== -1) {
//         // Повертаємо новий масив, видаляючи один елемент за індексом, а саме:
//         // 1. розпаковуємо частину масиву від індекса 0 до того індекса де ми знайшли потрібний елемент(той що видаляємо)
//         // 2. розпаковуємо другу частину масиву від індекса наступного від потрібного елемента(той що видаляємо) і до кінця масива
//         // 3. таким чином ми розпаковуємо весь початковий масив крім того елемента який потрібно було видалити
//         // 4. Обєднуємо обидва шматки масива в один новий масив (бо розпаковуємо їх послідовно в [])
//         // 5. Повертаємо копію зконкатенованого масиву 
//         return [...list.slice(0, index), ...list.slice(index + 1)];
//       }
//       // Якщо товар не знайдено (індекс -1), повертаємо незмінну копію списку
//       return [...list];
// }

// function checkProduct (list, item) {
//     return list.includes(item);
// }

// console.log(manageShoppingList(productsList, 'add', 'banana'));
// console.log(manageShoppingList(productsList, 'remove', 'apple'));
// console.log(manageShoppingList(productsList, 'check', 'pomegranate'));
// console.log(productsList);





// Завдання 13: Аналіз тексту та підрахунок слів
// Напишіть одну функцію analyzeTextAndCount, яка приймає два аргументи:
// text: рядок, що містить речення з текстом.
// stopwords: масив рядків, які потрібно виключити з аналізу.
// Функція повинна:
// Перетворити весь текст на нижній регістр.
// Видалити з тексту всю пунктуацію (коми, крапки, знаки оклику тощо).
// Видалити всі слова, які містяться у масиві stopwords.
// Підрахувати, скільки разів кожне слово, що залишилося, зустрічається в тексті.
// Повернути об'єкт, де ключами будуть слова, а значеннями — їхня кількість.
// Наприклад:
// Якщо text = "Привіт, світ! Привіт, JavaScript." і stopwords = ['привіт'], ваша функція повинна повернути: { світ: 1, javascript: 1 }.


// const text = 'Привіт, світ! Я вивчаю JavaScript, тому що JavaScript — це круто, і це дуже цікаво.';
// const stopwords = ['я', 'це', 'що', 'і', 'дуже', 'тому', 'що'];

// /**
//  * Аналізує текст, видаляючи стоп-слова та підраховуючи частоту кожного слова.
//  * @param {string} text - Початковий рядок тексту.
//  * @param {string[]} stopwords - Масив слів, які потрібно виключити.
//  * @returns {object} Об'єкт з частотою слів.
//  */
// function analyzeTextAndCount(text, stopwords) {
//   const textLower = text
//     .toLowerCase()
//     .replaceAll(/[.,!?;:"—'-]/g, '')
//     .replaceAll(/\s+/g, ' ')
//     .split(' ');

//     const filteredWords = textLower.filter((word) => !stopwords.includes(word))
//     const wordCounts = filteredWords.reduce((acc, word) => {
//         // Перевіряємо, чи слово вже є в акумуляторі (об'єкті acc) через дужкову нотацію, тому що word це змінна що містить значення для нашої властивості
//         if (acc[word]) {
//             // Якщо так, збільшуємо його значення
//             acc[word] += 1;
//         } else {
//             // Якщо ні, ініціалізуємо його зі значенням 1
//             acc[word] = 1;
//         }
//         // Завжди повертаємо акумулятор для наступної ітерації
//         return acc;

//     }, {});  // Початкове значення акумулятора - порожній об'єкт

//     return wordCounts;  

// }

// console.log(analyzeTextAndCount(text, stopwords));





// Ваше завдання
// А тепер ваше завдання: напишіть функцію countVowels, яка підраховує кількість голосних літер у рядку.
// Голосні: 'a', 'e', 'i', 'o', 'u' (не забувайте про українські, якщо хочете: 'а', 'е', 'и', 'і', 'ї', 'о', 'у', 'ю', 'я').
// Використайте reduce і порожній об'єкт як початкове значення. На кожній ітерації перевіряйте, чи поточна літера є голосною,
//  і оновлюйте акумулятор. Якщо ви виявите голосну, ви можете або збільшити загальний лічильник, або, що складніше, 
//  підрахувати кількість кожної окремої голосної.

// const str = 'Привіт світ у тебе є я';

// /**
//  * Counts every vowel in string
//  * @param {string} string - string to count vowels
//  * @returns {object} Object of vowels and their quantity
//  */
// function countVowels(string) {
//     const clearStr = string.toLowerCase().split('');
//     const vowels = ['a', 'o', 'u', 'e', 'i', 'а', 'о', 'у', 'е', 'и', 'і', 'ї', 'є', 'ю', 'я'];
//     // debugger;
//     const countedVowels = clearStr.reduce((acc, char) => {
//         if (vowels.includes(char)) {

//             acc[char] ? acc[char] += 1 : acc[char] = 1;

//             // Ще коротший і крутіший варіант :
//             // Якщо властивість не існує, acc[char] буде undefined тому Оператор || поверне 0 а потім ми додамо 1 
//             // (acc[char] || 0 поверне 0, потім 0 + 1 буде = 1.)
//             // Якщо властивість вже існує то повернеться 1, а потім вираз 1 + 1, де ми отримаєм друге входження, поім третє, тощо
//             // acc[char] = (acc[char] || 0) + 1;
//         }
//         return acc;
//     }, {})
//     return countedVowels;
// }

// console.log(countVowels(str));




// Завдання 14
// Напишіть функцію wordFrequency, яка приймає рядок і повертає об'єкт з кількістю входжень кожного слова.
// Не забувайте переводити всі слова в нижній регістр.
// Видаліть усі розділові знаки (., ,, !, ? тощо), щоб вони не впливали на підрахунок.

// function wordFrequency(str) {
//     // debugger;
//     const clearStrToArr = str
//         .toLowerCase()
//         .replaceAll(/[.—,!?;:"'–-]/g, '')
//         .replaceAll(/\s+/g, ' ')
//         .trim()
//         .split(' ')
//         .reduce((acc,currWord) => {
//             if (currWord) {
//             // acc[currWord] ? acc[currWord] += 1 : acc[currWord] = 1;
//             acc[currWord] = (acc[currWord] || 0) + 1;
//             }

//             return acc;
//         }, {});

//     return clearStrToArr;
// }

// const text = 'Оповідання — невеликий за обсягом прозовий твір, у якому зображувалась одна подія з життя одного або двох сформованих персонажів. Невеликі розміри оповідання вимагають нерозгалуженого, як правило, однолінійного, чіткого за побудовою сюжету.';
// console.log(wordFrequency(text));



// Завдання: Пошук електронних адрес
// Напиши функцію на JavaScript, яка приймає великий текст і знаходить у ньому всі електронні адреси. Результатом має бути масив з усіма знайденими адресами.
// Ось кілька вимог:
// Функція повинна знайти всі адреси, незалежно від того, де вони знаходяться в тексті.
// Вона має бути чутливою до регістру, але результат має повертати у нижньому регістрі.
// Адреси можуть містити літери, цифри, крапки та тире.
// Підказка:
// Секрет успіху тут — у правильному регулярному виразі.  Електронна адреса має чітку структуру: іменна_частина@домен.зона.
// іменна_частина: Це може бути будь-яка кількість літер, цифр, крапок (.) або тире (-). Ти вже знаєш, як позначати "один або більше" символів.
// @: Це фіксований символ.
// домен.зона: Тут також можуть бути літери, цифри, тире та крапки. Особливу увагу зверни на крапку: у регулярних виразах вона має спеціальне значення, тому її потрібно "екранувати" (захистити) за допомогою зворотного слеша (\).
// Щоб знайти всі збіги, а не тільки перший, тобі знадобиться спеціальний прапорець g (від "global") після регулярного виразу. А також метод match() для рядка.



// /**
//  * Знаходить всі електронні адреси у тексті.
//  * @param {string} text - Текст для пошуку.
//  * @returns {Array<string>} Масив знайдених електронних адрес.
//  */
// function findEmails(text) {

//     const emailRegex = /[^\s@]+@[^\s@]+\.[^\s@]+/g;
//     const matches = text.match(emailRegex);
//     console.log(emailRegex.test(text));

//     return matches;
// }

// const longText = `
// Привіт! Зв'яжіться з нами за адресою info@example.com або my.name@sub-domain.co.uk. 
// Якщо виникнуть питання, пишіть на support@example.org. 
// Також ми використовуємо admin@company.net для адміністративних потреб.
// Додаткова інформація доступна на сайті, а також за адресою test@testcom.
// `;

// const foundEmails = findEmails(longText);

// if (foundEmails) {
//   console.log("Знайдені електронні адреси:");
//   foundEmails.forEach(email => console.log(email));
// } else {
//   console.log("Електронні адреси не знайдено.");
// }






// Завдання 15:
// Напиши функцію generateEmailMessage, яка приймає масив об'єктів. Кожен об'єкт представляє одного співробітника та містить таку інформацію:
// firstName (рядок)
// lastName (рядок)
// department (рядок)
// salary (число)
// Функція повинна повернути новий масив, де кожен елемент — це рядок, що є готовим повідомленням для співробітника.
// Формат повідомлення:
// "Вітаємо, [Ім'я] [Прізвище]! Ваша нова зарплата на посаді у відділі [Відділ] становить $[Зарплата]. З найкращими побажаннями, HR-відділ."
// Деталі та підказки
// Для початку, тобі потрібно буде пройтися по масиву об'єктів.
// Зверни увагу на те, як отримати доступ до значень всередині кожного об'єкта.
// Для створення повідомлення тобі знадобиться шаблонний рядок (template literal).

// const employees = [
//     {
//         firstName: 'Anna',
//         lastName : 'Makar',
//         department: 'sales',
//         salary: 15000.00
//     },
//     {
//         firstName: 'Maryna',
//         lastName : 'Kruk',
//         department: 'advertisement',
//         salary: 13000.00
//     },
//     {
//         firstName: 'Vasya',
//         lastName : 'Petryk',
//         department: 'front-office',
//         salary: 17000.00
//     }
// ];

// /**
//  * Generates messages from data got from array
//  * @param {Array} arr - Array of objects with data to generate message
//  * @returns {Array} Array of text-messages
//  */
// function generateEmailMessage(arr) {
//     const messages = arr.reduce((acc, employee) => {
//         if(employee) {
//             acc.push(`Вітаємо, ${employee.firstName} ${employee.lastName}! Ваша нова зарплата на посаді у відділі ${employee.department.charAt(0).toUpperCase() + employee.department.slice(1)} становить ${employee.salary.toFixed(2)}. З найкращими побажаннями, HR-відділ. `)
//         }
//         return acc;
//     }, [])
//     return messages;
// }

// console.log(generateEmailMessage(employees));





// Завдання 16
// Уявімо, що наша компанія розширюється, і нам потрібно об'єднати дані з двох різних джерел.
// Твоє завдання — написати функцію mergeAndProcessData, яка приймає два масиви:
// Масив employees: Містить об'єкти з інформацією про співробітників, але без даних про їхні відділи та зарплату. Кожен об'єкт має такі властивості: id (унікальний ідентифікатор), firstName та lastName.
// Масив salaries: Містить об'єкти, що пов'язують ідентифікатор співробітника (id) з його зарплатою та відділом. Кожен об'єкт має такі властивості: id, department та salary.
// Функція повинна повернути новий масив об'єктів, де кожен об'єкт містить повну інформацію про співробітника, об'єднану з обох масивів.
// Формат вихідного об'єкта:
// {
//     id: 1,
//     firstName: 'Anna',
//     lastName: 'Makar',
//     department: 'sales',
//     salary: 15000
// }
// Деталі та підказки
// Для цього завдання тобі знадобиться пройтися по одному з масивів (наприклад, по employees).
// Для кожного співробітника з першого масиву тобі потрібно буде знайти відповідні дані в другому масиві, використовуючи спільний id.
// Після цього, ти маєш створити новий об'єкт, який поєднає всю інформацію.
// Зверни увагу, що порядок елементів у вихідному масиві не має значення.

// const employees = [
//     {
//         id: 101,
//         firstName: 'Anna',
//         lastName : 'Makar',

//     },
//     {
//         id: 102,
//         firstName: 'Maryna',
//         lastName : 'Kruk',

//     },
//     {
//         id: 103,
//         firstName: 'Vasya',
//         lastName : 'Petryk',

//     },
//     {
//         id: 105,
//         firstName: 'Olena',
//         lastName: 'Tsupko'
//     }
// ];

// const salaries = [
//     {
//         id: 101,
//         department: 'sales',
//         salary: 15000.00
//     },
//     {
//         id: 102,
//         department: 'advertisement',
//         salary: 13000.00
//     },
//     {
//         id: 103,
//         department: 'front-office',
//         salary: 17000.00
//     },
//     {
//         id: 104,
//         department: 'back-office',
//         salary: 19000.00
//     }
// ];


// // /**
// //  * Merges data of two Arrays of objects 
// //  * @param {Array} obj1 - Aray of objects
// //  * @param {Array} obj2 - Array of objects
// //  * @returns {Array} Array of merged objects
// //  */
// // function mergeAndProcessData(employees, salaries) {
// // // debugger;

// //     return employees.reduce((acc, employee) => {
// //         // Для кожного співробітника знаходимо відповідний об'єкт зарплати за id.
// //         const salaryData = salaries.find(salary => salary.id === employee.id);

// //         if (salaryData) {
// //             // ...створюємо новий об'єкт, який об'єднує дані з обох джерел
// //             // за допомогою оператора розгортання (...), властивості які вже існують просо перезапишуться.
// //             const mergedObject = {
// //                 ...employee,
// //                 ...salaryData
// //             }
// //             // Додаємо об'єднаний об'єкт до акумулятора.
// //             acc.push(mergedObject);
// //         }
// //         // Повертаємо акумулятор для наступної ітерації.
// //         return acc;
// //     }, [])

// // }

// // console.log(mergeAndProcessData(employees, salaries));


// /**
//  * Merges data of two Arrays of objects 
//  * @param {Array} obj1 - Aray of objects
//  * @param {Array} obj2 - Array of objects
//  * @returns {Array} Array of merged objects
//  */
// function mergeAndProcessData(employees, salaries) {

//     // return employees.map(employee => {

//     //     const salaryData = salaries.find(salary => salary.id === employee.id);

//     //     if(salaryData) {
//     //         return {
//     //             ...employee,
//     //             ...salaryData
//     //         }
//     //     }

//     // })


//     // // Покращений варіант з використанням flatMap замість map
//     // // Використовуємо flatMap(), щоб створити новий масив з об'єднаних об'єктів.
//     // // Якщо об'єкт salaryData не знайдено, flatMap проігнорує undefined.
//     // return employees.flatMap(employee => {
//     //     const salaryData = salaries.find(salary => salary.id === employee.id);

//     //     // Якщо salaryData знайдено, повертаємо масив, що містить об'єднаний об'єкт.
//     //     // Якщо ні, повертаємо порожній масив [].
//     //     // flatMap автоматично "вирівнює" ці масиви в один.
//     //     return salaryData ? [{ ...employee, ...salaryData }] : [];
//     // });


//     // Ще більш продвинуте рішення щоб не ітерувати масив 1000 раз в пошаку кожного індекса це зберегти дані в обєкт index: object
//       // 1. Створення індексу для масиву salaries для швидкого доступу.
//       // Використовуємо метод reduce(), щоб перетворити масив у об'єкт.
//       const salariesIndex = salaries.reduce((index, salary) => {
//         index[salary.id] = salary;
//         return index;
//       }, {});

//         // 2. Ітерація по масиву employees і об'єднання даних.
//         // Використовуємо map() для створення нового масиву.
//         return employees.map(employee => {
//             // Швидкий пошук за id через створений індекс.
//             const salaryData = salariesIndex[employee.id];
//             // Якщо ми знайшли відповідні дані...
//             if (salaryData) {
//                 // ...об'єднуємо їх у новий об'єкт.
//                 return {
//                     ...employee,
//                     ...salaryData
//                 };
//             }
//             // Якщо дані не знайдені, повертаємо початковий об'єкт employee,
//             // або null/undefined, якщо це потрібно за логікою.
//             return employee;
//         })

// }

// // написати функцію, яка знаходить всі заплати, у яких немає даних про співробітників

// /**
//  * Знаходить об'єкти зарплат, які не мають відповідного співробітника.
//  * @param {Array<Object>} employees - Масив об'єктів співробітників.
//  * @param {Array<Object>} salaries - Масив об'єктів зарплат.
//  * @returns {Array<Object>} Масив об'єктів, які не мають пари.
//  */
// function findUnmatchedSalaries(employees, salaries) {
//   // 1. Створюємо індекс для масиву employees для швидкого пошуку.
//   const employeesIndex = employees.reduce((index, employee) => {
//     index[employee.id] = employee;
//     return index;
//   }, {});

//   // 2. Використовуємо filter(), щоб знайти об'єкти, що не мають пари.
//   return salaries.filter(salary => {
//     // Перевіряємо, чи існує ключ salary.id в нашому індексі.
//     // Якщо його немає (тобто !employeesIndex[salary.id]),
//     // то цей об'єкт залишається в новому масиві.
//     return !employeesIndex[salary.id];
//   });
// }

// const unmatchedSalaries = findUnmatchedSalaries(employees, salaries);
// console.log(unmatchedSalaries);


// //  написати функцію, яка знаходить всіх співробітників, у яких немає даних про зарплату? Це буде схоже на щойно написаний нами код.
// /**
//  * Знаходить об'єкти співробітників, які не мають відповідної зарплати.
//  * @param {Array<Object>} employees - Масив об'єктів співробітників.
//  * @param {Array<Object>} salaries - Масив об'єктів зарплат.
//  * @returns {Array<Object>} Масив об'єктів, які не мають пари.
//  */
// function findUnmatchedEmployees(employees, salaries) {
//   // 1. Створюємо індекс для масиву employees для швидкого пошуку.
//   const salariesIndex = salaries.reduce((index, salary) => {
//     index[salary.id] = salary;
//     return index;
//   }, {});

//   // 2. Використовуємо filter(), щоб знайти об'єкти, що не мають пари.
//   return employees.filter(employee => {
//     // Перевіряємо, чи існує ключ salary.id в нашому індексі.
//     // Якщо його немає (тобто !employeesIndex[salary.id]),
//     // то цей об'єкт залишається в новому масиві.
//     return !salariesIndex[employee.id];
//   });
// }
// const unmatchedEmployees = findUnmatchedEmployees(employees, salaries);
// console.log(unmatchedEmployees);

// console.log(mergeAndProcessData(employees, salaries));



// Завдання 16: Облік товарів у магазині
// У тебе є масив об'єктів products, який містить інформацію про різні товари. Кожен об'єкт має таку структуру:
// name (рядок): назва товару.
// price (число): ціна товару.
// tags (масив рядків): список тегів, які описують товар (наприклад, ['електроніка', 'гаджети']).
// Твоє завдання:
// Напиши функцію calculateTotalPriceByTag(products, tag), яка:
// Приймає два аргументи: масив products та рядок tag.
// Проходить по всьому масиву products.
// Знаходить усі товари, які мають вказаний тег у своєму масиві tags.
// Підраховує та повертає загальну суму цін знайдених товарів.
// Якщо жоден товар не відповідає тегу, функція має повернути 0.
// Початкові дані для тестування:
// const products = [
//   { name: 'Ноутбук', price: 25000, tags: ['електроніка', 'гаджети'] },
//   { name: 'Кавоварка', price: 5000, tags: ['побутова техніка', 'кухня'] },
//   { name: 'Смартфон', price: 15000, tags: ['електроніка', 'мобільні'] },
//   { name: 'Навушники', price: 1500, tags: ['електроніка', 'аксесуари'] },
//   { name: 'Мікрохвильовка', price: 8000, tags: ['побутова техніка', 'кухня'] },
//   { name: 'Клавіатура', price: 2000, tags: ['аксесуари'] }
// ];


// const products = [
//   { name: 'Ноутбук', price: 25000, tags: ['електроніка', 'гаджети'] },
//   { name: 'Кавоварка', price: 5000, tags: ['побутова техніка', 'кухня'] },
//   { name: 'Смартфон', price: 15000, tags: ['електроніка', 'мобільні'] },
//   { name: 'Навушники', price: 1500, tags: ['електроніка', 'аксесуари'] },
//   { name: 'Мікрохвильовка', price: 8000, tags: ['побутова техніка', 'кухня'] },
//   { name: 'Клавіатура', price: 2000, tags: ['аксесуари'] }
// ];


// function calculateTotalPriceByTag(products, tag) {

//     return products.reduce((sum, product) => {
//         return product.tags.includes(tag) ? sum += product.price : sum;

//     }, 0)
// }

// console.log(calculateTotalPriceByTag(products, 'ванна'));


// **Наступне завдання 17: Форматування даних**
// Давай попрацюємо зі рядками. Твоє завдання — перетворити масив об'єктів з попереднього завдання в єдиний, 
// відформатований рядок, який можна було б вивести в консоль або на сторінку.
// **Твоє завдання:**
// Напиши функцію `formatProductList(products)`, яка:
// 1.  Приймає один аргумент: масив `products` з попереднього завдання.
// 2.  Використовуючи методи масивів та рядків, створює єдиний рядок, який містить інформацію про кожен товар.
// 3.  Кожен товар має бути на новому рядку.
// 4.  Формат для кожного товару має бути таким:
//     `Назва: [name] | Ціна: [price] грн | Теги: [tags_list]`
// 5.  Теги в `[tags_list]` мають бути розділені комою та пробілом.
// ---
// **Приклад очікуваного результату:**
// ```
// Назва: Ноутбук | Ціна: 25000 грн | Теги: електроніка, гаджети
// Назва: Кавоварка | Ціна: 5000 грн | Теги: побутова техніка, кухня
// Назва: Смартфон | Ціна: 15000 грн | Теги: електроніка, мобільні
// Назва: Навушники | Ціна: 1500 грн | Теги: електроніка, аксесуари
// Назва: Мікрохвильовка | Ціна: 8000 грн | Теги: побутова техніка, кухня
// Назва: Клавіатура | Ціна: 2000 грн | Теги: аксесуари


// function formatProductList(products) {
//     const formattedArray = products.map(product => {
//         const tagsString = product.tags.join(', ');
//         const formattedPrice = product.price.toFixed(2);
//         return `Назва: ${product.name} | Ціна: ${formattedPrice} грн | Теги: ${tagsString}`;
//     })

//     return formattedArray.join('\n');

// }

// const formattedOutput = formatProductList(products);
// console.log(formattedOutput);


// **Наступне завдання 18: Аналіз тегів**
// Давай попрацюємо з об'єктами. Твоє завдання — створити об'єкт, який буде містити інформацію про кількість товарів для кожного тегу.
// **Твоє завдання:**
// Напиши функцію `countTags(products)`, яка:
// 1.  Приймає один аргумент: масив `products` з попереднього завдання.
// 2.  Створює новий порожній об'єкт.
// 3.  Проходить по всьому масиву `products`.
// 4.  Для кожного товару проходить по його масиву `tags`.
// 5.  Якщо тег вже існує в об'єкті, збільшує його лічильник на **1**.
// 6.  Якщо тег ще не існує, додає його в об'єкт з лічильником **1**.
// 7.  Повертає фінальний об'єкт з кількістю товарів для кожного тегу.
// **Приклад очікуваного результату:**
// {
//   'електроніка': 3,
//   'гаджети': 1,
//   'побутова техніка': 2,
//   'кухня': 2,
//   'мобільні': 1,
//   'аксесуари': 2
// }



// function countTags(products) {

//     return products.reduce((tagsAmount, product) => {

//             product.tags.forEach(tag => {
//                 tagsAmount[tag] = tagsAmount[tag] ? tagsAmount[tag] += 1 : 1;
//             })

//         return tagsAmount;
//     }, {})
// }


// const countedTags = countTags(products);
// console.log(countedTags);



// Наступне завдання 19: Фільтрування та сортування
// Тепер, коли ми вміємо працювати з даними, давай їх відфільтруємо та відсортуємо.
// Твоє завдання:
// Напиши функцію filterAndSort(products, maxPrice, sortBy), яка:
// Приймає три аргументи:
// products: масив товарів (з попередніх завдань).
// maxPrice: максимальна ціна, за якою потрібно відфільтрувати товари.
// sortBy: рядок 'price' або 'name', за яким потрібно відсортувати відфільтровані товари.
// Спочатку фільтрує масив, залишаючи тільки ті товари, ціна яких менша або дорівнює maxPrice.
// Потім сортує відфільтрований масив за вказаним параметром sortBy.
// Якщо sortBy дорівнює 'price', сортувати від найдешевшого до найдорожчого.
// Якщо sortBy дорівнює 'name', сортувати за назвою в алфавітному порядку.
// Повертає новий, відфільтрований та відсортований масив.
// debugger;


// function filterAndSort(products, maxPrice, sortBy) {

//     const productsMaxPrice = products.filter( product => product.price <= maxPrice);

//     const sortedProducts = productsMaxPrice.toSorted((a,b) => {
//         if(a[sortBy] > b[sortBy]) {
//             return 1;
//         } else if(a[sortBy] < b[sortBy]) {
//             return -1;
//         } else {
//             return 0;
//         }
//     });
//     return sortedProducts;
// }

// const sortedAndFiltered = filterAndSort(products, 12000, 'name');
// console.log(sortedAndFiltered);


// Твоє завдання 20:
// Напиши функцію groupAndSummarize(products). Ця функція повинна:
// Приймати один аргумент: products, масив товарів.
// Використовуючи reduce, вона повинна згрупувати товари за їхнім першим тегом.
// Для кожної групи (тегу), вона повинна повернути об'єкт з такими властивостями:
// count: загальна кількість товарів у цій групі.
// totalPrice: загальна ціна всіх товарів у цій групі.
// Повернути кінцевий об'єкт, де ключі — це теги, а значення — об'єкти з підсумковими даними.


// function groupAndSummarize(products) {

//     return products.reduce((group, curr) => {
//         // debugger;
//         if(group.hasOwnProperty(curr.tags[0])) {
//             group[curr.tags[0]].count += 1;
//             group[curr.tags[0]].totalPrice += curr.price;
//         } else {
//             group[curr.tags[0]] = {count: 1, totalPrice: curr.price};
//         }

//         return group;
        
//     }, {})

// }

// const groupedAndSummarized = groupAndSummarize(products);
// console.log(groupedAndSummarized);



// Наступне завдання 21
// Давай спробуємо інше завдання, яке допоможе закріпити навички роботи з масивами.
// Твоє завдання:
// Напиши функцію findUniqueTags(products). Ця функція повинна:
// Приймати один аргумент: products, масив товарів.
// Використовуючи методи масивів (наприклад, map, flat, reduce, filter або Set), знайти усі унікальні теги з усіх товарів у масиві products.
// Повернути новий масив, який містить лише унікальні теги, без повторень.

// function findUniqueTags(products) {
// // debugger;

//   const flattenedProducts = products.map(product => {
    
//     const getTags = product.tags.reduce((acc, curr) => {
//       if (curr) {
//         acc.push(curr);
//       }
//       return acc;
//     }, []);

//     return getTags;
//   }).flat();

//   const productsUniqueTags = Array.from(new Set(flattenedProducts))

//   return productsUniqueTags;
  
// }

// const foundUniqueTags = findUniqueTags(products);
// console.log(foundUniqueTags);


// /**
//  * Варіант 1: Використання reduce()
//  * @param {Array<Object>} products - Масив об'єктів товарів.
//  * @returns {Array<string>} Масив унікальних тегів.
//  */
// function findUniqueTags1(products) {
//     // 1. Використовуємо reduce() для зведення всіх тегів в один масив.
//     const allTags = products.reduce((accumulator, currentProduct) => {
//         return accumulator.concat(currentProduct.tags);
//     }, []); // Початкове значення - порожній масив.

//     // 2. Створюємо Set з масиву, щоб отримати унікальні значення.
//     const uniqueTagsSet = new Set(allTags);

//     // 3. Перетворюємо Set назад у масив.
//     return Array.from(uniqueTagsSet);
// }



// Варіант 2: Використання map() та flat() - ще більш лаконічний
// function findUniqueTags2(products) {
//     // 1. Збираємо всі теги в один масив.
//     const allTags = products.map(product => product.tags).flat();
    
//     // 2. Створюємо та повертаємо масив з унікальних значень.
//     return [...new Set(allTags)];
// }


// const foundUniqueTags1 = findUniqueTags(products);
// console.log('Унікальні теги (Варіант 1):', foundUniqueTags);
// const foundUniqueTags2 = findUniqueTags2(products);
// console.log('Унікальні теги (Варіант 2):', foundUniqueTags2);





// Наступне завдання 21: Узагальнення даних
// Ми навчилися працювати з масивами, але тепер давай спробуємо створити функцію, яка узагальнює дані про всі товари.
// Твоє завдання:
// Напиши функцію getStoreSummary(products), яка:
// Приймає один аргумент: products, масив товарів.
// Повертає новий об'єкт, що містить такі підсумкові дані про всі товари:
// totalProducts: загальна кількість товарів.
// totalPrice: загальна вартість усіх товарів.
// averagePrice: середня ціна одного товару (округлена до двох знаків після коми).
// uniqueTags: масив усіх унікальних тегів (використай свою функцію з попереднього завдання!).


// function getStoreSummary(products) {

//   const totalPr = +products.reduce((accum, currProduct) => {
//     accum += currProduct.price;
//     return accum;
//   }, 0).toFixed(2);

//   const avaragePr = +(totalPr / products.length).toFixed(2);

//   const uniqueT = Array.from(new Set(products.map(product => product.tags).flat())); 

//   return {
//     totalProducts: products.length,
//     totalPrice: totalPr,
//     avaragePrice: avaragePr,
//     uniqueTags: uniqueT
//   }

// }

// const storeSummary = getStoreSummary(products);
// console.log(storeSummary);



// //Ще один спосіб щоб лише один раз перебарти вхідний масив і зібрати за один раз всі необхідні дані
// /**
//  * Повертає зведену інформацію про товари в магазині.
//  * @param {Array<Object>} products - Масив об'єктів товарів.
//  * @returns {Object} Об'єкт з підсумковими даними.
//  */
// function getStoreSummary(products) {
//     // Використовуємо reduce для зведення всіх даних за один прохід.
//     const summary = products.reduce((acc, product) => {
//         // Збираємо загальну ціну.
//         acc.totalPrice += product.price;

//         // Збираємо всі теги у Set, щоб отримати унікальні.
//         product.tags.forEach(tag => acc.uniqueTags.add(tag));

//         return acc;
//     }, {
//         // Початкові значення
//         totalPrice: 0,
//         uniqueTags: new Set()
//     });

//     const totalProducts = products.length;
//     const averagePrice = totalProducts > 0 ? parseFloat((summary.totalPrice / totalProducts).toFixed(2)) : 0;

//     return {
//         totalProducts: totalProducts,
//         totalPrice: parseFloat(summary.totalPrice.toFixed(2)),
//         averagePrice: averagePrice,
//         uniqueTags: Array.from(summary.uniqueTags)
//     };
// }

// const storeSummary = getStoreSummary(products);
// console.log(storeSummary);





// --------------------------------------------------------------------------------------------------------------------------------

// Завдання
// Уяви, що ти розробляєш програму для аналізу тексту.
//  Твоє завдання — написати функцію, яка приймає рядок тексту і повертає об'єкт зі статистикою по ньому.
// Цей об'єкт повинен містити таку інформацію:
// Загальна кількість слів: порахувати, скільки слів у тексті.
// Унікальні слова: масив, що містить тільки унікальні слова (без дублікатів).
// Частота слів: об'єкт, де ключами є слова, а значеннями — кількість їхніх повторень у тексті.
// Покроковий план
// Створи функцію, яка приймає один аргумент — text.
// Спочатку тобі потрібно перетворити рядок у масив слів. Подумай, який метод рядків тобі допоможе.
// Очисти слова від знаків пунктуації (коми, крапки, знаки оклику тощо) і перетвори їх у нижній регістр, 
// щоб Слово та слово вважалися одним і тим же словом.
// Створи об'єкт для зберігання результатів.
// Пройдись по масиву слів, заповнюючи статистику.
// Поверни готовий об'єкт.







// ---------------------------------------------------------------------------------------------------------------------------------------------

// Завдання 1: Фабрика вітань 🏭
// Створіть функцію createGreeting, яка приймає один аргумент greeting (наприклад, 'Привіт', 'Вітаю', 'Вітання').
//  Ця функція повинна повертати іншу функцію, яка, у свою чергу, приймає аргумент name і виводить у консоль повне вітання.
// Приклад використання:
// const greetInEnglish = createGreeting('Hello');
// const greetInUkrainian = createGreeting('Привіт');

// greetInEnglish('John'); // Очікуваний результат: "Hello, John!"
// greetInUkrainian('Іван'); // Очікуваний результат: "Привіт, Іван!"


// function createGreeting (greeting) {
//   debugger;
//   return function(name) {
//     console.log(`${greeting}, ${name}!`);
//   }
// }

// const greetInEnglish = createGreeting('Hello');
// const greetInSpanish = createGreeting('Hola');

// greetInEnglish('George');
// greetInSpanish('Lucía');






// Завдання 2: Приватний лічильник 🔒
// Використовуючи замикання, створіть функцію createCounter, яка повертає об'єкт з трьома методами:
// increment(): збільшує приватний лічильник на 1.
// decrement(): зменшує приватний лічильник на 1.
// getValue(): повертає поточне значення лічильника.
// Важливо: До самої змінної лічильника (наприклад, count) не повинно бути прямого доступу ззовні.
// Приклад використання:
// const counter = createCounter();

// counter.increment();
// counter.increment();
// console.log(counter.getValue()); // Очікуваний результат: 2

// counter.decrement();
// console.log(counter.getValue()); // Очікуваний результат: 1

// function createCounter() {
  
//   let counter = 0;

//     return {
//       increment: function(){
//         return counter += 1;
//       },
//       decrement: function(){
//         return counter -= 1;
//       },
//       getValue: function() {
//         return counter;
//       }
//     }
// }
// const counter = createCounter();
// counter.increment();
// counter.increment();
// counter.increment();
// console.log(counter.getValue()); // Очікуваний результат: 2 ->  3
// counter.decrement();
// console.log(counter.getValue()); // Очікуваний результат: 1 ->  2


// Завдання 3: Медіа-плеєр 🎵
// Створіть функцію createPlayer, яка приймає масив пісень. Ця функція повинна повертати об'єкт з наступними методами:
// play(): виводить у консоль "Playing [поточна_пісня]".
// next(): переходить до наступної пісні у списку. Якщо поточна пісня остання, переходить до першої.
// prev(): переходить до попередньої пісні. Якщо поточна пісня перша, переходить до останньої.
// Використайте замикання, щоб зберегти поточний індекс пісні та список пісень.
// Приклад використання:


// const mySongs = ['Song A', 'Song B', 'Song C'];
// const player = createPlayer(mySongs);

// player.play(); // Очікуваний результат: "Playing Song A"
// player.next();
// player.play(); // Очікуваний результат: "Playing Song B"
// player.next();
// player.next();
// player.play(); // Очікуваний результат: "Playing Song A"


// function createPlayer(playList) {
//   let indexOfcurrentSong = 0; 

//   return {
//     play: function() {
//       console.log(`Playing ${playList[indexOfcurrentSong]}`);
//     },
//     next: function() {
//       if (indexOfcurrentSong < playList.length - 1) {
//         indexOfcurrentSong += 1;
//       } else {
//         indexOfcurrentSong = 0;
//       }
//     },
//     prev: function() {
//       if (indexOfcurrentSong > 0) {
//          indexOfcurrentSong -= 1;
//       } else {
//         indexOfcurrentSong = playList.length - 1;
//       }
//     }
//   }
// }


// const mySongs = ['Song A', 'Song B', 'Song C'];
// const player = createPlayer(mySongs);
// player.play();
// player.next();
// player.play();


// const mySongs2 = ['Song A', 'Song B', 'Song C'];
// console.log(mySongs2);
// console.log(mySongs2[0]);
// console.log(mySongs2[0 + 1]);









// Завдання 5: Генератор ідентифікаторів (ID Generator) 🔢
// Створіть функцію makeIdGenerator, яка не приймає жодних аргументів.
//  Ця функція повинна повертати іншу функцію. Кожен раз, коли повернена функція викликається, 
// вона повинна генерувати та повертати наступне послідовне число, починаючи з 1.
// Використовуйте замикання, щоб зберегти поточний ID.
// Приклад використання:
// const getNextId = makeIdGenerator();
// console.log(getNextId()); // Очікуваний результат: 1
// сonsole.log(getNextId()); // Очікуваний результат: 2
// console.log(getNextId()); // Очікуваний результат: 3
// const getAnotherId = makeIdGenerator(); // Створюємо новий, незалежний генератор
// console.log(getAnotherId()); // Очікуваний результат: 1

// function makeIdGenerator() {

//   //1. БАТЬКІВСЬКЕ ЛЕКСИЧНЕ ОТОЧЕННЯ (SCOPE)
//   let id = 0;   // змінна id знаходиться в батьківському лексичному оточенні (makeIdGenerator). Вона є "Приватною"

//   // 2. ФУНКЦІЯ-ЗАМИКАННЯ
//   // nextId це функція замикання, внутрішня функція яка оголошена в батьківському scope. 
//   // Вона запам'ятовує доступ до id через Лексичне оточення.
//   return function nextId() {   
//     // 3. ВИКОРИСТАННЯ ЗОВНІШНЬОЇ ЗМІННОЇ
//     // Коли викликається nextId(), вона шукає 'id' у своєму scope.
//     // Не знайшовши її, вона йде по "Ланцюжку областей видимості"
//     // і знаходить 'id' у батьківському оточенні.
//     id += 1;  // оновлює значення в батьківському scope
//     return id;  // повертає оновлене значення
//   }
// }

// // 4. СТВОРЕННЯ ПЕРШОГО ЗАМИКАННЯ
// // 'getNextId' отримує внутрішню функцію (closure).
// // Вона має в собі посилання на Лексичне Оточення, де 'id' = 0.
// const getNextId = makeIdGenerator();
// // 5. ВИКЛИКИ
// console.log(getNextId());  // Викликаємо closure. 'id' стає 1, повертає 1.
// console.log(getNextId());  // Викликаємо те саме closure. 'id' стає 2, повертає 2.
// console.log(getNextId());  // Викликаємо те саме closure. 'id' стає 3, повертає 3.


// 6. СТВОРЕННЯ ДРУГОГО, НЕЗАЛЕЖНОГО ЗАМИКАННЯ
// 'getAnotherId' отримує НОВУ внутрішню функцію (closure).
// Вона має своє ВЛАСНЕ, окреме посилання на нове Лексичне Оточення, де 'id' = 0.
// const getAnotherId = makeIdGenerator();
// // 7. НЕЗАЛЕЖНІ ВИКЛИКИ
// console.log(getAnotherId());
// console.log(getAnotherId());
// console.log(getAnotherId());






// Завдання 6: Функція налаштування податку 💰
// Створіть функцію taxCalculator, яка приймає один аргумент — відсоток податку (наприклад, 0.20 для 20%). 
// Ця функція повинна повертати іншу функцію.
// Повернена функція повинна приймати суму і повертати суму з нарахованим податком.
// Приклад використання:
// const calculateWithVAT = taxCalculator(0.20); // ПДВ 20%
// const calculateWithSalesTax = taxCalculator(0.05); // Податок 5%
// console.log(calculateWithVAT(100)); // Очікуваний результат: 120 (100 + 20%)
// console.log(calculateWithVAT(500)); // Очікуваний результат: 600
// console.log(calculateWithSalesTax(100)); // Очікуваний результат: 105 (100 + 5%)


// function taxCalculator(percentage) {
//   return function sumWithTax(sum) {
//     return sum + (sum * percentage);
//   }
// }

// const calculateWithVAT = taxCalculator(0.20); 
// const calculateWithSalesTax = taxCalculator(0.05);
// console.log(calculateWithVAT(100));
// console.log(calculateWithVAT(500));
// console.log(calculateWithSalesTax(100));



// Завдання 7: Збереження останнього повідомлення 💬
// Створіть функцію messageKeeper, яка повертає об'єкт з двома методами:
// setMessage(text): зберігає переданий рядок у приватній змінній.
// getLastMessage(): повертає останнє збережене повідомлення.
// Використовуйте замикання, щоб приховати змінну, яка зберігає повідомлення.
// Приклад використання:
// const keeper = messageKeeper();
// keeper.setMessage('Перше повідомлення');
// console.log(keeper.getLastMessage()); // Очікуваний результат: "Перше повідомлення"
// keeper.setMessage('Друге повідомлення');
// console.log(keeper.getLastMessage()); // Очікуваний результат: "Друге повідомлення"
// // console.log(keeper.message); // Спроба доступу до приватної змінної має призвести до помилки/undefined

// function messageKeeper(){
//   let message;
//   return {
//     setMessage: function (text) {
//       message = text;
//     },
//     getLastMessage: function () {
//       return message;
//     }
//   }
// }

// const keeper = messageKeeper();
// keeper.setMessage('Перше повідомлення');
// console.log(keeper.getLastMessage()); // Очікуваний результат: "Перше повідомлення"
// keeper.setMessage('Друге повідомлення');
// console.log(keeper.getLastMessage()); // Очікуваний результат: "Друге повідомлення"
// keeper.setMessage('Третє повідомлення');
// console.log(keeper.getLastMessage()); // Очікуваний результат: "Третє повідомлення"
// // console.log(keeper.message); // Спроба доступу до приватної змінної має призвести до помилки/undefined

// const keeper2 = messageKeeper();
// keeper2.setMessage('Перше повідомлення');
// console.log(keeper2.getLastMessage()); // Очікуваний результат: "Перше повідомлення"
// keeper2.setMessage('Друге повідомлення');
// console.log(keeper2.getLastMessage()); // Очікуваний результат: "Друге повідомлення"
// keeper2.setMessage('Третє повідомлення');
// console.log(keeper2.getLastMessage()); // Очікуваний результат: "Третє повідомлення"
// // console.log(keeper.message); // Спроба доступу до приватної змінної має призвести до помилки/undefined






// Завдання 1: Сума чисел до N 🔢
// Створіть рекурсивну функцію sumToN(n), яка обчислює суму всіх цілих чисел від 1 до n.
// Рекурсивна формула: S(n)=n+S(n−1)
// Базовий випадок: S(1)=1
// Приклад використання:
// console.log(sumToN(5)); // Очікуваний результат: 1 + 2 + 3 + 4 + 5 = 15
// console.log(sumToN(3)); // Очікуваний результат: 1 + 2 + 3 = 6


// function sumToN(n) {
//   debugger;
//   if (n === 1) {
//     return 1;
//   }
//   return n + sumToN(n-1);
// }
// console.log(sumToN(5));
// console.log(sumToN(3)); 
// // 1
// // 2 + 1 = 3
// // 3 + 3 = 6
// // 4 + 6 = 10
// // 5 + 10 = 15



// Завдання 2: Зворотний відлік 🚀
// Створіть рекурсивну функцію countDown(n), яка виводить у консоль числа від n до 1, а потім виводить повідомлення "Пуск!" (Launch!).
// Базовий випадок: Коли n=0.
// Приклад використання:
// countDown(3);
// // Очікуваний вивід:
// // 3
// // 2
// // 1
// // Пуск!

// function countDown(num) {
//   // debugger;
//   if (num===0) {
//     return console.log('Launch!');
//   }
//   console.log(num);
//   countDown(num-1);
// }
// countDown(3);







// Завдання 3: Переворот рядка 🔄
// Створіть рекурсивну функцію reverseString(str), яка приймає рядок і повертає його у зворотному порядку.
// Підказка: На кожному кроці відокремлюйте перший символ і додавайте його до кінця результату рекурсивного виклику для решти рядка.
// Reverse("hello")=Reverse("ello")+"h"
// Базовий випадок: Коли довжина рядка дорівнює 0 або 1.
// Приклад використання:
// console.log(reverseString('hello')); // Очікуваний результат: "olleh"
// console.log(reverseString('cat'));   // Очікуваний результат: "tac"

// function reverseString(str) {
//   // debugger;

//   if (str.length <= 1) {
//     return str;
//   }

//   const remainder = str.slice(1);

//   const firstChar = str.charAt(0);
//   return reverseString(remainder) + firstChar;


// }
// console.log(reverseString('hello'));



// Завдання 4: Числа Фібоначчі (Fibonacci Sequence) 🐇
// Створіть рекурсивну функцію fibonacci(n), яка повертає n-те число в послідовності Фібоначчі.
// Послідовність Фібоначчі починається з 0 і 1. Кожне наступне число є сумою двох попередніх: 0,1,1,2,3,5,8,13,…
// Рекурсивна формула: Fib(n)=Fib(n−1)+Fib(n−2)
// Базові випадки:
// Fib(0)=0
// Fib(1)=1
// Приклад використання:
// console.log(fibonacci(6)); // Очікуваний результат: 8 (0, 1, 1, 2, 3, 5, 8) - під індексом 6
// console.log(fibonacci(4)); // Очікуваний результат: 3 (0, 1, 1, 2, 3, 5, 8) - під індексом 4


// function fibonacci(n) {

//   if (n === 0) {
//     return 0;
//   }
//   if (n === 1) {
//     return 1;
//   }
//   return fibonacci(n - 1) + fibonacci(n - 2);
// }

// console.log(fibonacci(4));
// console.log(fibonacci(6));



// Завдання 5: Обчислення експоненти (Степінь) ⚡
// Створіть рекурсивну функцію power(base, exponent), яка обчислює степінь (base exponent). 
// Увага: це завдання ми вже обговорювали, тепер ваша черга реалізувати його!
// Рекурсивна формула: an =a×a n−1
//  Базовий випадок: a0 =1
// Приклад використання:
// console.log(power(2, 3)); // Очікуваний результат: 8 (2 * 2 * 2)
// console.log(power(5, 0)); // Очікуваний результат: 1


// function power(base, exponent) {
//   if (exponent === 0) {
//     return 1;
//   }
//   return base * power(base, exponent - 1);
// }

// console.log(power(2, 3));
// console.log(power(5, 0));
// console.log(power(5, 5));



// Завдання 6: Сума всіх значень вкладеного масиву 📦 (Середній рівень)
// Створіть рекурсивну функцію sumNestedArray(arr), яка обчислює суму всіх чисел у масиві, 
// який може містити як числа, так і інші масиви (вкладеність не обмежена).
// Підказка: Вам потрібно буде перевіряти, чи є елемент числом (додаємо його), чи масивом (викликаємо для нього рекурсію).
// Приклад використання:
// const nestedArr = [1, 2, [3, 4, [5]], 6];
// console.log(sumNestedArray(nestedArr)); // Очікуваний результат: 21 (1+2+3+4+5+6)


// function sumNestedArray(arr) {
//   let sum = 0;
//     for (item of arr) {
//       if (Array.isArray(item)) {
//         sum += sumNestedArray(item);
//       } else {
//         sum += item;
//       }
//     }
//     return sum;

// }

// const nestedArr = [1, 2, [3, 4, [5]], 6];
// console.log(sumNestedArray(nestedArr));



// Завдання 7: Перевірка на Паліндром 🔄
// Створіть рекурсивну функцію isPalindrome(str), яка перевіряє, чи є заданий рядок паліндромом (тобто читається однаково в обох напрямках).
// Підказка: На кожному кроці порівнюйте перший і останній символи.
//  Якщо вони збігаються, викликайте функцію для середньої частини рядка (без цих двох символів).
// Базові випадки:
// Рядок порожній або містить лише один символ (завжди паліндром).
// Перший і останній символи не збігаються (не паліндром).
// Приклад використання:
// console.log(isPalindrome('racecar')); // Очікуваний результат: true
// console.log(isPalindrome('hello'));   // Очікуваний результат: false

// function isPalindrome(str) {
//     if (typeof str !== 'string') {
//         return false;
//     }
//     if (str.length <= 1) {
//         return true;
//     }
//     if (str[0] !== str[str.length - 1]) {
//         return false;
//     }
    
//     const stepInStr = str.slice(1, -1);
//     return isPalindrome(stepInStr);

// }

// console.log(isPalindrome('racecar'));
// console.log(isPalindrome('hello'));
// console.log(isPalindrome(123));



// Завдання 8: Глибоке множення 🌟 (Середній рівень)
// Створіть рекурсивну функцію deepMultiply(obj), яка приймає об'єкт. 
// Цей об'єкт містить лише числа та інші об'єкти (вкладеність не обмежена). 
// Функція повинна обчислити добуток усіх числових значень в об'єкті та всіх його вкладених об'єктах.
// Підказка: Вам потрібно буде перебрати ключі об'єкта. Якщо значення є числом, множте його. 
// Якщо значення є об'єктом, викликайте функцію рекурсивно і множте на результат.
// Базовий випадок (неявний): Коли ви обробляєте число (не потрібен подальший рекурсивний виклик).
// Приклад використання:
// const data = {
//   a: 2,
//   b: {
//     c: 3,
//     d: {
//       e: 4
//     }
//   },
//   f: 1
// };
// console.log(deepMultiply(data)); // Очікуваний результат: 2 * 3 * 4 * 1 = 24

// function deepMultiply(obj) {
//     debugger;
//     let total = 1;
    
//     for (key in obj) {

//         if (typeof obj[key] === 'object') {
//             total *= deepMultiply(obj[key]);
//         } else {
//             total *= obj[key];
//         }


//     }
//     return total;
// }

// console.log(deepMultiply(data));





// Завдання 9: Плоска структура (Flatten Array) 🥞
// Створіть рекурсивну функцію flattenArray(arr), яка приймає масив із будь-якою кількістю 
// вкладених масивів і повертає новий, одномірний (плоский) масив.
// Підказка: Використовуйте метод масиву concat() або оператор розгортання (...) разом із рекурсією.
// Базовий випадок: Коли елемент, який ви переглядаєте, не є масивом.
// Приклад використання:
// const nested = [1, [2, [3, 18, 4], 5], 6];
// console.log(flattenArray(nested)); // Очікуваний результат: [1, 2, 3, 4, 5, 6]

// function flattenArray(arr) {
//     // debugger;
//     let flattenedArray = [];
//     for (item of arr) {
//         if (Array.isArray(item)) {
//             flattenedArray = flattenedArray.concat(flattenArray(item));
//         } else {
//             flattenedArray = flattenedArray.concat(item);
//         }
//     }
//     return flattenedArray;
// }
// console.log(flattenArray(nested));




// Завдання 10: Кількість входжень символу 🔍
// Створіть рекурсивну функцію countChar(str, char), яка підраховує, 
// скільки разів певний символ (char) зустрічається у заданому рядку (str).
// Підказка: На кожному кроці перевіряйте перший символ. 
// Якщо він збігається з шуканим, додайте 1 до результату рекурсивного виклику для решти рядка.
// Базовий випадок: Коли рядок порожній.
// Приклад використання:

// console.log(countChar('programming', 'g')); // Очікуваний результат: 2
// console.log(countChar('hello', 'z'));     // Очікуваний результат: 0


// function countChar(str, char) {
// // debugger;
//     let amount = 0;
//     if(str.length < 1) {
//         return 0;
//     }
//     if (str[0] === char) {
//         amount += 1;
        
//     }
//     const innerStr = str.slice(1)
//     amount += countChar(innerStr, char);
//     return amount;

// }

// console.log(countChar('programming', 'g'));
// console.log(countChar('hello', 'z'));

// function countChar(str, char) {
// // debugger;
//     if (str.length === 0) {
//         return 0;
//     }

//     const isMatch = str[0] === char ? 1 : 0;

//     const restOfStr = str.slice(1);

//     return isMatch + countChar(restOfStr, char);

// }

// console.log(countChar('programming', 'g'));
// console.log(countChar('hello', 'z'));




// Завдання 11: Обхід дерева (Складний об'єкт) 🌳 (Просунуте)
// Створіть рекурсивну функцію findPath(tree, targetName), яка знаходить і повертає повний шлях 
// (у вигляді масиву імен) до об'єкта, що має властивість name, яка збігається з targetName. 
// Структура "дерева" являє собою об'єкт, де вкладені елементи знаходяться у властивості children (яке є масивом).
// Базовий випадок 1: Поточний вузол відповідає цілі.
// Базовий випадок 2: Вузол не має дочірніх елементів, а ціль не знайдено.
// Приклад використання:

// const companyTree = {
//   name: "CEO",
//   children: [
//     {
//       name: "Manager",
//       children: [
//         { name: "TeamLead",
//           children: [
//             { name: "Developer" }
//           ]
//         }
//       ]
//     },
//     { name: "Support" }
//   ]
// };

// // // Очікуваний результат: ['CEO', 'Manager', 'TeamLead', 'Developer']
// // console.log(findPath(companyTree, 'Developer')); 

// // // Очікуваний результат: null або []
// // console.log(findPath(companyTree, 'HR')); 


// function findPath(tree, targetName) {
//     debugger;

//     // 1. БАЗОВИЙ ВИПАДОК (Успіх): Поточний вузол є ціллю
//     if (tree.name === targetName) {
//         return [tree.name];
//     }

//     // 2. РЕКУРСИВНИЙ КРОК
//     // Перевіряємо, чи є дочірні елементи для обходу
//     if (tree.children && tree.children.length > 0) {

//         // Перебираємо дочірні елементи children
//         for (const child of tree.children) {

//             // Викликаємо рекурсію для дочірнього вузла
//             const pathFromChild = findPath(child, targetName);

//             // 3. ОБРОБКА РЕЗУЛЬТАТУ:
//             // Якщо рекурсивний виклик повернув шлях (тобто не порожній масив/null)
//             if (pathFromChild && pathFromChild.length > 0) {
//                 // Додаємо ім'я поточного вузла (вузол - це обєкт що має властивість name) на ПОЧАТОК знайденого шляху
//                 // tree.name на останньому рівні (де tree.name === targetName (Developer)) = 'TeamLead', бо TeamLead є батьківським для Developer
//                 // тобто у вузлі TeamLead ми досягли його дочірнього елемента що шукали (Developer). Як попередній крок

//                 pathFromChild.unshift(tree.name);
//                 // функція(крок рекурсії) для TeamLead зберігає в локальне оточення весь обєкт який має 
//                 // властивість name: 'TeamLead' допоки перевіряє children цього ж обєкта. Він чекає... 
//                 // потім коли до нього повертається результат який не пустий ми в контексті функції для TeamLead, 
//                 // маємо збережений обєкт TeamLead який має властивість name:'TeamLead' і самЕ значення цієї 
//                 // властивості в самЕ цьому контексті ми зберігаємо в масив, і так по колу доки не дійдемо до СЕО
//                 console.log(tree.name);
//             }

//                         // Ми у функції findPath, яка була викликана для вузла TeamLead
//                         // const pathFromChild = findPath(Developer_об'єкт, 'Developer'); 
//                         // // pathFromChild = ['Developer']

//                         // if (pathFromChild.length > 0) {
//                         //     // tree.name на цьому рівні = 'TeamLead', наступний крок = 'Manager', наступний крок = 'CEO'
//                         //     pathFromChild.unshift(tree.name); // Додаємо 'TeamLead', наступний крок додаємо Manager, наступний крок додаємо CEO
//                         //     // pathFromChild тепер = ['TeamLead', 'Developer'] ,наступний крок ['Manager', 'TeamLead', 'Developer'], наступний крок ['CEO', 'Manager', 'TeamLead', 'Developer']
                            
//                         //     return pathFromChild; // Повертаємо це до Manager, наступний крок повертаємо все до CEO, ми дійшли до самого початку тому повертається вже масив pathFromChild

//             // І одразу повертаємо знайдений шлях, зупиняючи подальший обхід
//             return pathFromChild;
//         }
//     }


//     // 4. БАЗОВИЙ ВИПАДОК (Невдача): Якщо гілка обійдена, і ціль не знайдено
//     return []; 
// }
// console.log(findPath(companyTree, 'Developer'));








// Завдання 12: Рекурсивний map 🗺️ (Просунуте)
// Створіть рекурсивну функцію recursiveMap(arr, callback), яка приймає масив (що може містити вкладені масиви)
//  та функцію зворотного виклику (callback). Функція повинна застосувати callback до кожного числового елемента, 
//  зберігаючи при цьому початкову структуру вкладеності масивів.
// Підказка: Вам потрібно буде ітерувати масив і, якщо елемент є масивом, викликати recursiveMap для нього. 
// Якщо елемент є числом, застосуйте callback.
// Приклад використання:

// const nestedNumbers = [1, [2, [3, 4]], 5];

// // // Приклад callback: функція, що подвоює число
// const double = (n) => n * 2; 

// // // Очікуваний результат: [2, [4, [6, 8]], 10]
// // console.log(recursiveMap(nestedNumbers, double)); 

// function recursiveMap(arr, cb) {
//     return arr.map(num => {
//         return Array.isArray(num) ? recursiveMap(num, cb) : cb(num);
//     })
// }
// console.log(recursiveMap(nestedNumbers, double))



// Фінальний Набір Завдань: Глибока Рекурсія
// Завдання 13: Пошук у Глибину (DFS) 🌲
// Створіть рекурсивну функцію deepFind(obj, targetKey), яка перевіряє, чи містить об'єкт 
// або будь-який із його вкладених об'єктів (обмежень на глибину немає) заданий ключ targetKey. 
// Функція має повернути true або false.

// Підказка: Використовуйте for...in для ітерації об'єкта. Якщо значення є об'єктом, викликайте
//  функцію рекурсивно. Як тільки true повернуто на будь-якому рівні, негайно повертайте true догори.

// Базовий випадок (Успіх): Ключ знайдено на поточному рівні.
// Базовий випадок (Невдача): Об'єкт перебрано, і ключ не знайдено.

// Приклад використання:

// const structure = {
//   id: 1,
//   data: {
//     user: 'Alice',
//     details: {
//       location: 'UA',
//       secret_key: 42 // <--- Шуканий ключ
//     }
//   },
//   meta: {}
// };


// function deepFind(obj, targetKey) {

//     // debugger;
//     if (obj.hasOwnProperty(targetKey)) {
//         return true;
//     }

//     for (const key in obj) {


//         if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
//             const result = deepFind(obj[key], targetKey);

//             // КЛЮЧОВИЙ МОМЕНТ: Якщо рекурсія повернула TRUE, негайно повертаємо TRUE
//             if (result === true) {
//                 return true;
//             }
//             // Інакше (якщо result === false), цикл продовжується до наступної гілки.
//         }

//     }
//     return false;
// }

// console.log(deepFind(structure, 'secret_key')); // Очікуваний результат: true
// console.log(deepFind(structure, 'meta')); // Очікуваний результат: true
// console.log(deepFind(structure, 'user')); // Очікуваний результат: true
// console.log(deepFind(structure, 'unknown_key')); // Очікуваний результат: false




// Завдання 14: Сума цифр числа (Одинарна рекурсія) 🧮
// Створіть рекурсивну функцію sumDigits(n), яка обчислює суму всіх цифр цілого позитивного числа n.
// Підказка: Для отримання останньої цифри використовуйте оператор остачі від ділення (% 10). 
// Для отримання решти числа використовуйте Math.floor(n / 10).
// Рекурсивна формула: Sum(n)=(n(mod10))+Sum(⌊n/10⌋)
// Базовий випадок: Коли n=0.
// Приклад використання:
// console.log(sumDigits(1234)); // Очікуваний результат: 1 + 2 + 3 + 4 = 10
// console.log(sumDigits(905));  // Очікуваний результат: 9 + 0 + 5 = 14


// function sumDigits(n) {

//     let sum;

//     if (n === 0) {
//         return 0;
//     } else {

//         sum = (n % 10) + sumDigits(Math.floor(n / 10));
//     }
//     return sum;
// }
// console.log(sumDigits(905));


// Приклад виконання для sumDigits(905)
// sumDigits(905): 5+sumDigits(90)
// sumDigits(90): 0+sumDigits(9)
// sumDigits(9): 9+sumDigits(0)
// sumDigits(0): Повертає 0 (Базовий випадок).
// Розкручується стек:
// Підйом: 9+0=9.
// Підйом: 0+9=9.
// Підйом: 5+9=14 (Кінцевий результат).





// Завдання 15: Зворотний Обхід Дерева (Застосування досвіду Завдання 11) 📜
// Використовуючи структуру дерева з Завдання 11, створіть рекурсивну 
// функцію listAllNames(tree), яка повертає однорівневий масив, що містить всі 
// name з дерева, у порядку обходу (зліва направо).
// Підказка: Вам потрібно використовувати складання масивів (наприклад, concat()
//  або оператор розгортання ...) під час обходу, аналогічно до того, як ви робили 
// це в Завданні 9 (Flatten Array), але застосовуючи до структури дерева.
// Принцип: List(Node)=[Node.name]+List(Child1)+List(Child2)+…
// Приклад використання:
// const companyTree = { /* ... те саме дерево ... */ };
// // Очікуваний результат: ['CEO', 'Manager', 'TeamLead', 'Developer', 'Support']
// console.log(listAllNames(companyTree));


// const companyTree = {
//   name: "CEO",
//   children: [
//     {
//       name: "Manager",
//       children: [
//         { name: "TeamLead",
//           children: [
//             { name: "Developer" }
//           ]
//         }
//       ]
//     },
//     { name: "Support" }
//   ]
// };


// function listAllNames(tree) {
//     let listNames = []
//     // debugger;

//     if (tree.name) {
//         listNames.push(tree.name);
//     }

//     if (tree.children && tree.children.length > 0) {
//         for  (const child of tree.children) {

//             const pathToChild = listAllNames(child);

//             if (pathToChild && pathToChild.length > 0) {

//                 listNames = [...listNames, ...pathToChild];
                
//             }

//         }
//     }
//     return listNames;

// }

// console.log(listAllNames(companyTree));


// -----------------------------------------------------------------------------------------------------------------------------------

// Завдання 16: Валідація користувача та Генерація Помилок
// Створіть функцію validateUser(user), яка приймає об'єкт користувача. Функція повинна:
// Перевірити, чи має об'єкт властивість age. Якщо ні, кинути ReferenceError з повідомленням: "Властивість 'age' обов'язкова."
// Перевірити, чи є значення age числом. Якщо ні, кинути TypeError з повідомленням: "Вік має бути числом."
// Якщо валідація успішна, повернути true.
// Потім створіть блок try...catch і протестуйте функцію з такими вхідними даними:
// { name: 'Alice', email: 'a@e.com' } (Очікуйте ReferenceError)
// { name: 'Bob', age: 'двадцять' } (Очікуйте TypeError)
// { name: 'Charlie', age: 30 } (Очікуйте true)




// function validateUser(user) {
//     if (!user.age) {   // !('age' in user) або !user.hasOwnProperty('age') - більш строга перевірка саме наявності властивості в обєкті
//         throw new ReferenceError('Властивість \'age\' обов\'язкова.');
//     }
//     if (typeof user.age !== 'number') {
//         throw new TypeError('Вік має бути числом.');
//     }
//     return true;
// }

// try {
//     // validateUser({ name: 'Alice', email: 'a@e.com' });
//     // validateUser({ name: 'Bob', age: 'двадцять' });
//     validateUser({ name: 'Charlie', age: 30 });
// } catch (e) {
//     console.log(e);
// }




// Завдання 17: Селективна Обробка та finally
// Створіть функцію processData(data), яка:
// Якщо data є null, кидає Error з повідомленням: "Дані відсутні (null)."
// Якщо data не є масивом, кидає TypeError з повідомленням: "Дані повинні бути масивом."
// Потім створіть блок try...catch...finally для її виклику. У блоці catch використовуйте instanceof для:
// Обробки TypeError: Вивести "Помилка формату: [текст помилки]".
// Обробки будь-якої іншої помилки: Вивести "Невідома помилка: [текст помилки]".
// У блоці finally: Вивести "Очищення: Обробка завершена, незалежно від результату."
// Протестуйте з processData(123) та processData(null).


// function processData(data) {
//     if (data === null) {
//         throw new Error('Дані відсутні (null).');
//     }
//     if (!Array.isArray(data)) {
//         throw new TypeError('Дані повинні бути масивом.');
//     }
// }

// try {
//     // processData(null);
//     processData(123);
//     // processData([123]);
// } catch(e) {
//     if (e instanceof TypeError) {
//         console.log(`Помилка формату: ${e.message}`);  // якщо ми виведем лише ${e} то отримаєм зайвий текст Помилка формату: TypeError: Дані повинні бути масивом.
//     } else {                                   // замість Помилка формату: Дані повинні бути масивом. - зайвим буде e.name 
//         console.log(`Невідома помилка: ${e.message}`);
//     }

// } finally {
//     console.log('Очищення: Обробка завершена, незалежно від результату.');
// }





// Завдання 18: Перекидання Помилки та Ланцюжок Викликів
// Створіть дві функції:
// calculate(x, y): Виконує ділення x / y. Якщо y дорівнює 0, 
// вона повинна кинути новий Error з повідомленням "Ділення на нуль заборонено!".
// runCalculation(a, b): Викликає calculate(a, b) всередині try...catch.
// Якщо виникає помилка, вона повинна вивести: "Внутрішня помилка обчислення: [текст помилки]".
// Потім вона повинна знову кинути ту ж саму помилку (throw error;) для передачі вище.
// Нарешті, викличте runCalculation(10, 0) всередині зовнішнього try...catch і обробіть помилку там,
//  вивівши: "Зовнішній обробник зловив помилку: [текст помилки]".

// function calculate(x, y) {
//     if (y === 0) {
//         throw new Error('Ділення на нуль заборонено!');
//     }
    
//     return x / y;
// }

// function runCalculation(a, b) {
//     let result;
//     try {
//         result =  calculate(a, b);
//     } catch(e) {
//         console.log(`Внутрішня помилка обчислення: ${e.message}`);
//         throw e;
//     }
//     console.log(result);
//     return result;
// }

// try {
//     runCalculation(10, 2);
// } catch(e) {
//     console.log(`Зовнішній обробник зловив помилку: ${e.message}`);
// }


// Завдання 19: Ігнорування Помилок та Звіт
// Створіть функцію safeProcessList(dataList), яка приймає масив об'єктів або значень (dataList).
//  Функція повинна перебрати цей масив і спробувати викликати функцію processItem(item) для кожного елемента.
// Створіть функцію processItem(item), яка кидає:
// TypeError, якщо item не є об'єктом.
// RangeError, якщо item.value менше 100.
// Вимоги до safeProcessList:
// Оберніть виклик processItem(item) у try...catch.
// Якщо виникає TypeError, його слід ігнорувати (не кидати далі), але записати в консоль: "Пропущено: невірний тип."
// Якщо виникає RangeError, його слід перекинути далі (throw error;), оскільки це критична помилка бізнес-логіки.
// Функція повинна повернути true, якщо успішно дійшла до кінця, або false, якщо RangeError було перехоплено і перекинуто.

// const list = [
//     {value: 120},
//     {value: 150}
// ];


// const safeProcessList = function(dataList) {
//     // Прапорець для відстеження критичної помилки
//     let hasCriticalError = false;

//     for (let item of dataList) {
//         try {
//             processItem(item);
//             // console.log(item);

//         } catch (e) {
//             if (e instanceof TypeError) {
//                 console.log(`Пропущено: ${e.message}`);
//                 continue;      // Явно продовжуємо цикл
//             }
//             if (e instanceof RangeError) {
//                 console.error(`Критична помилка: ${e.message}`);
//                 hasCriticalError = true;   // Встановлюємо прапорець
//                 break;   // Негайно виходимо з циклу for
//             }
//         }
        
//     }

//     if (hasCriticalError) {
//         return false;
//     } else {
//         return true;
//     }

// }

// function processItem(item) {
//     if (typeof item !== 'object') {
//         throw new TypeError(`${item} не є об'єктом`);
//     }
//     if (item.value < 100) {
//         throw new RangeError(`Значення ${item.value} менше ніж 100`);
//     }
// }

// // safeProcessList(list);
// console.log(safeProcessList(list));



//Варіант 2 рішення якщо залишити re-throw (e) що відповідає ппатерну "локальний лог + глобальна реакція"

// const list = [
//     {value: 120},
//     {value: 90}
// ];

// const safeProcessList = function safeProcessList(dataList) {
//     for (let item of dataList) {
//         try {
//             processItem(item);
//         } catch (e) {
//             if (e instanceof TypeError) {
//                 // 1. TypeError: Ігноруємо та продовжуємо
//                 console.log(`Пропущено: ${e.message}`);
//                 continue; 
//             }
//             if (e instanceof RangeError) {
//                 // 2. RangeError: Перекидаємо. ФУНКЦІЯ ТУТ ЖЕ ЗАВЕРШУЄТЬСЯ
//                 console.error(`Критичний виняток: ${e.message}`); 
//                 throw e; 
//             }
//         }
//     }
//     // Цей рядок буде досягнуто, лише якщо не було RangeError
//     return true; 
// }

// // Початковий виклик тепер має бути обгорнутий у зовнішній try...catch
// try {
//     const result = safeProcessList(list);
//     console.log(`Обробка завершена. Результат: ${result}`); // true, якщо успіх
// } catch (e) {
//     if (e instanceof RangeError) {
//         console.error("ЗОВНІШНІЙ РІВЕНЬ: Обробка перекинутої критичної помилки.");
//         // Тут би ви повернули false або зупинили транзакцію, але функція вже кинула помилку.
//     }
//     console.log(`Обробка завершена. Результат: false`); 
// }

// function processItem(item) {
//     if (typeof item !== 'object') {
//         throw new TypeError(`${item} не є об'єктом`);
//     }
//     if (item.value < 100) {
//         throw new RangeError(`Значення ${item.value} менше ніж 100`);
//     }
// }

// console.log(safeProcessList(list));



// Завдання 20: Створення Власного Класу Помилки
// Створіть власний клас помилки, який наслідує стандартний Error:
// AuthorizationError:
// Властивість name повинна бути "AuthorizationError".
// Конструктор повинен приймати message та code (наприклад, 403).
// Створіть функцію checkAccess(userRole):
// Якщо userRole не є "admin", киньте AuthorizationError з кодом 403 та повідомленням "Доступ заборонено.".
// Нарешті, створіть блок try...catch, який:
// Перевіряє, чи помилка є AuthorizationError за допомогою instanceof.
// Якщо так, виводить: "Помилка авторизації [код]: [повідомлення]." (Використовуйте властивості code та message помилки).


// class AuthorizationError extends Error{
//     constructor(message, code){
//         super(message);
//         this.name = 'AuthorizationError';
//         this.code = code;

//     }
// }

// function checkAccess(userRole) {
//     if (userRole !== 'admin') {
//         throw new AuthorizationError('Access denied', 403);
//     }
// }

// try {
//     checkAccess('manager')
// } catch(e) {
//     if (e instanceof AuthorizationError) {
//         console.log(`Помилка авторизації ${e.code}: ${e.message}.`);
//     } else {
//         throw e;
//     }
// }


// Завдання 21: Комбінація finally та return
// Створіть функцію safeDivide(a, b), яка:
// Якщо b дорівнює 0, кидає Error з повідомленням "Ділення на нуль.".
// У try повертає результат ділення a / b.
// У catch записує в консоль: "Була помилка. Повертаю 0." і повертає число 0.
// У finally записує в консоль: "Вихід із safeDivide."
// Питання для перевірки:
// Що поверне функція для safeDivide(10, 2) (успіх)?
// Що поверне функція для safeDivide(10, 0) (помилка)?
// У якому порядку виводяться повідомлення в обох випадках?/


// const safeDivide = function (a, b) {

//     try {
//         if (b === 0) {
//             // 1 Кидаєм помилку в середині try
//             throw new Error('Ділення на нуль.')
//         }

//         // 2. усппішне повернення якщо нема помилки
//         return a / b;
//     } catch(e) {
//         // 3. обробка помилки: виведення та  повернення 0
//         console.log('Була помилка. Повертаю 0.');
//         return 0;

//     } finally {
//         // 4. Виконується завжди, навіть якщо був return
//         console.log('Вихід із safeDivide.');
//     }

// }

// console.log(safeDivide(10, 0));

// // У випадку safeDivide(10, 2) спершу виводиться finally  а потім результат ділення(5)
// // У виппадку safeDivide(10, 0) спершу виводиться помилка, потім finally а потім 0




// Завдання 22: Рекурсивний Факторіал із Валідацією (Error-Proof Factorial) 🛠️
// Створіть рекурсивну функцію safeFactorial(n), яка обчислює факторіал цілого позитивного числа n (n!=1⋅2⋅⋯⋅n).
// Вимоги:
// Валідація: На початку функції safeFactorial(n) додайте блок валідації, який кидає помилки, якщо:
// n не є числом (наприклад, рядок): кинути TypeError з повідомленням "Вхідні дані мають бути числом."
// n є негативним або не є цілим числом (наприклад, 3.5): кинути RangeError з повідомленням "Число має бути позитивним цілим."
// Рекурсія: Якщо валідація успішна, виконайте рекурсивний розрахунок факторіалу:
// Базовий випадок: n=0 або n=1 повертає 1.
// Рекурсивний крок: Factorial(n)=n⋅Factorial(n−1).
// Тестування:
// Викличте функцію тричі в одному try...catch блоці для перевірки всіх шляхів:
// safeFactorial('привіт') (Очікуйте TypeError)
// safeFactorial(-5) (Очікуйте RangeError)
// safeFactorial(4) (Очікуйте успішний результат: 24)
// У блоці catch використайте instanceof для виведення конкретного повідомлення для кожного типу помилки.


// function safeFactorial(n) {
//     if (typeof n !== 'number') {
//         throw new TypeError('Вхідні дані мають бути числом.');
//     }
//     if (!Number.isSafeInteger(n) || n < 0) {
//         throw new RangeError('Число має бути позитивним цілим.');
//     }

//     if (n === 0 || n === 1) {
//         return 1;
//     }
//     return n * safeFactorial(n-1);
// }

// try{
//     // console.log(safeFactorial('привіт'));
//     // console.log(safeFactorial(5.1));;
//     // console.log(safeFactorial(-5));;
//     console.log(safeFactorial(4));;

// } catch(e) {
//     if (e instanceof TypeError) {
//         console.log(`${e.name}: ${e.message}`);
//     }
//     if (e instanceof RangeError) {
//         console.log(`${e.name}: ${e.message}`);
//     }
// }



// Завдання 23: Рекурсивний Пошук та Аварійне Завершення 🚧
// Створіть рекурсивну функцію deepSearchAndValidate(obj, targetValue), 
// яка шукає певне значення (targetValue) у вкладеному об'єкті (obj).
// Вимоги:
// Пошук: Виконуйте глибокий пошук (як у Завданні 13). 
// Якщо знайдено властивість зі значенням targetValue, функція повертає true.
// Аварійна Валідація: Якщо під час обходу ви знаходите будь-яку властивість з ключем 'critical_error', 
// ви повинні негайно кинути загальний Error з повідомленням "Критична властивість знайдена, обхід припинено.".
// Використовуйте try...catch зовні функції, щоб перехопити цю критичну помилку.
// Тестування:

// const data = {
//     a: 1,
//     b: {
//         c: 2,
//         d: {
//             e: 3,
//             f: {
//                 g: 'critical_error', // Повинно зупинити обхід тут
//                 h: 5
//             }
//         },
//         i: 4
//     }
// };
// // Тест 1: safeFactorial(data, 5) — 5 не буде знайдено
// // Тест 2: safeFactorial(data, 1) — Помилка не виникне, поверне true
// Ваше завдання — переконатися, що обхід негайно завершується, коли знайдено 'critical_error'
// , і зовнішній catch ловить цей виняток. Успіхів! 💪


// function deepSearchAndValidate(obj, targetValue) {

//     for (let key in obj) {
//         if (!obj.hasOwnProperty(key)) {  // перевіряємо чи key є власною властивістю обєкта а не успадкованою!!!
//             continue;  // якщо key успадкований - негайно припини поточну ітерацію і переходь до наступної властивості, 
//                         // якщо всі властивості цього обєкта успадковані поверни false 
//         }

//         if (obj[key] === 'critical_error') {
//             throw new Error('Критична властивість знайдена, обхід припинено.');
//         }
//         if (obj[key] === targetValue) {
//             return true;
//         }
        
//         if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
//             if(deepSearchAndValidate(obj[key], targetValue)) {
//                 return true;
//             }
//         }

//         }
    
//     return false;
// }

// try {
//     console.log(deepSearchAndValidate(data, 4));
//     // console.log(deepSearchAndValidate(data, 3));
// } catch(e) {
//     console.log(`${e.name}: ${e.message}`);
// }



// -----------------------------------------------------------------------------------------------------------------------------


// Ваше Завдання 24: Клас Користувача (User)
// Створіть свій перший клас User та його екземпляр.
// Створіть клас User.
// Додайте constructor, який приймає firstName та lastName.
// Ініціалізуйте ці властивості (використовуючи this).
// Додайте метод getFullName(), який повертає повне ім'я користувача (наприклад, "Іван Іваненко").
// Створіть екземпляр класу User (наприклад, const user1) і виведіть його повне ім'я за допомогою методу.


// class User {
//     constructor(firstName, lastName) {
//         this.name = firstName;
//         this.surname = lastName;
//     }

//     getFullName() {
//         return `${this.name} ${this.surname}`;
//     }
// }

// const user1 = new User('Іван', 'Іванченко');
// console.log(user1.getFullName());



// Завдання 25 (Переглянуте): Методи, Прототипи та Статика 🛠️
// Створіть клас Product для управління інформацією про товар.
// 1. Екземплярні Методи та Властивості
// Конструктор: Приймає name (назва товару) та price (ціна). Ініціалізуйте ці властивості.
// Метод getFormattedPrice(): Повертає ціну товару у форматі з валютою (наприклад, "150.00 UAH").
// Метод applyDiscount(percentage): Приймає відсоток знижки і повертає нову ціну після застосування 
// знижки (але не змінює оригінальну властивість this.price).
// 2. Статичний Метод
// Статичний метод comparePrices(productA, productB): Приймає два екземпляри класу Product і повертає назву товару з вищою ціною.
// 3. Тестування
// Створіть екземпляри та протестуйте:
// const laptop = new Product('Laptop', 25000);
// const mouse = new Product('Mouse', 1200);
// Викличте laptop.applyDiscount(10) та виведіть результат.
// Викличте Product.comparePrices(laptop, mouse) та виведіть результат.


// class Product {
//     constructor(name, price) {
//         this.name = name;
//         this.price = price;
//     }

//     getFormattedPrice() {
//         return `${this.price.toFixed(2)} UAH`;
//     }

//     applyDiscount(percentage) {

//         return (this.price - (this.price * percentage / 100));
//     }

//     static comparePrices(productA, productB) {
//         if (productA.price > productB.price) {
//             return productA.name;
//         } else {
//             return productB.name;
//         }
//     }
// }

// const laptop = new Product('laptop', 25000);
// const mouse = new Product('mouse', 1200);

// console.log(laptop.applyDiscount(10));
// console.log(Product.comparePrices(laptop, mouse));
// console.log(mouse.getFormattedPrice());



// Завдання 26 (Фінальна Ревізія): Методи, Прототипи та Статика
// Створимо клас Geometry для математичних розрахунків, який не містить приватних полів, 
// але фокусується на методах екземпляра та статичних методах.
// 1. Клас Geometry та Конструктор
// Конструктор: Приймає лише одну властивість pi та ініціалізує її значенням 3.14159.
// 2. Екземплярний Метод (Прототипний)
// Метод calculateCircleArea(radius): Приймає радіус, використовує this.pi для розрахунку площі кола (A=π⋅r2) та повертає результат.
// 3. Статичний Метод (Utility Method)
// Статичний метод calculateSquareArea(side): Приймає довжину сторони та повертає площу квадрата (A=side2). 
// Важливо: Цей метод не повинен використовувати жодних властивостей екземпляра (this).
// 4. Тестування
// Створіть екземпляр const calc = new Geometry();.
// Викличте метод екземпляра: calc.calculateCircleArea(5).
// Викличте статичний метод: Geometry.calculateSquareArea(4).
// Це завдання чітко розмежує:
// Метод екземпляра: Потребує this та створюється через new.
// Статичний метод: Не потребує this і викликається напряму на Класі.

// class Geometry{
//     constructor(){
//         this.pi = 3.14159;
//     }
//     calculateCircleArea(radius) {
//         return this.pi * (radius * radius);
//     }
//     static calculateSquareArea(side) {
//         return Math.pow(side,2);
//     }
// }

// const calc = new Geometry();
// console.log(calc.calculateCircleArea(5));
// console.log(Geometry.calculateCircleArea(4));



// Завдання 27: Клас із Геттерами та Сеттерами (Валідація імені)
// Створіть вдосконалений клас Person, який використовує геттери та сеттери для контролю над іменем.
// 1. Клас та Властивості
// Конструктор: Приймає firstName та lastName. Ініціалізуйте внутрішні властивості, використовуючи префікс
//  нижнього підкреслення (наприклад, this._firstName).
// 2. Сеттери (Валідація)
// Сеттер fullName:
// Приймає повне ім'я у вигляді рядка ("Ім'я Прізвище").
// Розділяє рядок на частини.
// Валідація: Якщо передано менше двох слів, кидає Error з повідомленням "Повне ім'я має містити Ім'я та Прізвище.".
// Якщо валідація успішна, присвоює this._firstName та this._lastName нові значення.
// 3. Геттери (Розрахунок)
// Геттер fullName: Повертає повне ім'я, об'єднане з this._firstName та this._lastName.
// 4. Тестування
// Створіть екземпляр: const person = new Person('Іван', 'Петренко');
// Читання (Геттер): Виведіть person.fullName.
// Запис (Сеттер): Присвойте нове, валідне ім'я: person.fullName = 'Олег Коваленко';
// Спроба невалідної зміни (Сеттер, обробка помилки):
// Обгорніть спробу присвоєння person.fullName = 'Андрій' у try...catch.
// У catch виведіть повідомлення про помилку.


// class Person{
//     constructor(firstName, lastName)  {
//         this._firstName = firstName;
//         this._lastName = lastName;
//     }

//     set fullName(value) {
//         const parts = value.split(' ');

//         if (parts.length !== 2) {
//             throw new Error('Повне ім\'я має містити Ім\'я та Прізвище.');
//         }
//         this._firstName = parts[0];
//         this._lastName = parts[1];

//     }
//     get fullName(){
//         return `${this._firstName} ${this._lastName}`;
//     }
// }

// const person = new Person('Олег', 'Хмарочос');
// // 1.читання початкового ім'я
// console.log(person.fullName);

// // 2. запис нововго валідного імя
// person.fullName = 'Валерій Дикий'
// console.log(person.fullName);


// // 3. спроба невалідного імені
// try{
//     person.fullName = 'Anna'
//     console.log(person.fullName);
// } catch(e) {
//     console.log(e.message);
// }

// // 4. імя після невдалої спроби - має залишитись валерій дикий
// console.log(person.fullName);



// Завдання 28: Клас Вкладник (Contributor) із Валідацією та Статикою 🔐
// Створіть клас Contributor (Вкладник) для системи управління проєктами, який контролює рівень його завантаженості та статус.
// 1. Приватні Конвенційні Поля
// this._hourlyRate (погодинна ставка)
// this._isActive (булеве значення: чи активний вкладник)
// 2. Конструктор
// Приймає name, rate та activeStatus.
// 3. Геттери та Сеттери
// Сеттер hourlyRate: Приймає нову ставку. Валідація: Якщо ставка менше 10 або не є числом, 
// кидає RangeError. Записує валідне значення у this._hourlyRate.
// Геттер hourlyRate: Повертає значення this._hourlyRate.
// Сеттер isActive: Приймає булеве значення. Валідація: Якщо значення не булеве, кидає TypeError. 
// Записує валідне значення у this._isActive.
// Геттер isActive: Повертає значення this._isActive.
// 4. Статичний Метод (Utility)
// Статичний метод calculateDailyCost(contributor): Приймає один екземпляр класу Contributor та 
// повертає його добову вартість, припускаючи 8-годинний робочий день, 
// лише якщо вкладник активний (contributor.isActive дорівнює true).
// Вартість: hourlyRate⋅8.
// Якщо вкладник неактивний, повертає 0.
// 5. Тестування
// Створіть екземпляри: const ann = new Contributor('Ann', 30, true); та const max = new Contributor('Max', 50, false);.
// Використовуйте сеттер: Спробуйте змінити ставку ann.hourlyRate = 45;.
// Спробуйте змінити статус: max.isActive = true;.
// Викличте Contributor.calculateDailyCost(ann) та Contributor.calculateDailyCost(max).
// Обгорніть спробу зміни ставки на невалідну (наприклад, ann.hourlyRate = 5;) у try...catch.

// class Contributor{
//     constructor(name, rate, activeStatus) {
//         this.name = name;
//         this._hourlyRate = rate;
//         this._isActive = activeStatus;
//     }

//     set hourlyRate(rate){
//         if (rate < 10 || typeof rate !== 'number') {
//             throw new RangeError('Invalid rate');
//         }
//         this._hourlyRate = rate;
//     }
//     get hourlyRate() {
//         return this._hourlyRate;
//     }
//     set isActive(activeStatus) {
//         // debugger;
//         if (typeof activeStatus !== 'boolean') {
//             throw new TypeError('Invalid actitivity status');
//         }
//         this._isActive = activeStatus;
//     }
//     get isActive() {
//         return this._isActive;
//     }
//     static calculateDailyCost(instance) {
//         if (instance.isActive === true) {
//             return instance.hourlyRate * 8;
//         } else {
//             return 0;
//         }
//     }
// }

// const ann = new Contributor('Ann', 30, true);
// const max = new Contributor('Max', 50, false);

// console.log(ann.hourlyRate);
// console.log(ann.isActive);
// console.log(max.hourlyRate);
// console.log(max.isActive);
// console.log(Contributor.calculateDailyCost(ann));
// console.log(Contributor.calculateDailyCost(max));
// ann.hourlyRate = 45;
// console.log(ann.hourlyRate);
// max.isActive = true;
// console.log(max.isActive);
// console.log(Contributor.calculateDailyCost(ann));
// console.log(Contributor.calculateDailyCost(max));

// try {
//     max.isActive = 5;
// } catch(e) {
//     console.log(e.message);
// }




// Завдання 29: Клас Перевірки Паролів (PasswordChecker) 🔒
// Створіть клас PasswordChecker, який перевірятиме безпечність паролів та зберігатиме статус перевірки.
// 1. Приватне Внутрішнє Поле
// this._password (рядок, для зберігання поточного пароля).
// 2. Сеттер (Валідація та Зберігання)
// Сеттер password: Приймає новий пароль.
// Валідація: Якщо довжина пароля менше 8 символів, кидає Error з повідомленням "Пароль повинен бути не менше 8 символів.".
// Якщо валідація успішна, зберігає пароль у this._password.
// 3. Геттер (Безпечне Читання)
// Геттер password: Повертає лише перші 3 символи пароля, а решту замінює зірочками (*). 
// (Наприклад, якщо пароль "Secure123", геттер поверне "Sec*****").
// 4. Статичний Метод (Загальна Перевірка)
// Статичний метод validatePasswordStrength(password): Приймає рядок (пароль).
// Виконує повну перевірку: повертає true, якщо пароль більше 8 символів ТА містить хоча б одну цифру.
//  В іншому випадку повертає false.
// Порада: Для перевірки наявності цифри використовуйте регулярний вираз (/\d/.test(password)).
// 5. Тестування
// Створіть екземпляр: const checker = new PasswordChecker();.
// Встановіть валідний пароль, використовуючи сеттер: checker.password = 'MySecret123';.
// Прочитайте пароль, використовуючи геттер, і переконайтеся, що він замаскований.
// Викличте статичний метод: PasswordChecker.validatePasswordStrength('testPass1') та PasswordChecker.validatePasswordStrength('weak').
// Обгорніть спробу присвоїти невалідний пароль (наприклад, 'short') у try...catch.

// class PasswordChecker {
//     constructor(pass) {
//         this._password = pass;
//     }
//     set password(pass) {
//         if (pass.length < 8) {
//             throw new Error('Пароль повинен бути не менше 8 символів.');
//         }
//         this._password = pass;
//     }
//     get password() {
//         return this._password.slice(0, 3).padEnd(this._password.length, '*');
//     }
//     static validatePasswordStrength(password) {
//         if (password.length >= 8 && /\d/.test(password)) {
//             return true;
//         }
//         return false;

//     }
// }

// const checker = new PasswordChecker();
// checker.password = 'blablablalala555';
// console.log(checker.password);
// console.log(PasswordChecker.validatePasswordStrength('testPass1'));
// console.log(PasswordChecker.validatePasswordStrength('weak'));

// try {
//     checker.password = 'short';
// } catch (e) {
//     console.log(e.message);
// }


